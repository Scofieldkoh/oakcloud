
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Tenant: 'Tenant',
  Role: 'Role',
  Permission: 'Permission',
  RolePermission: 'RolePermission',
  UserRoleAssignment: 'UserRoleAssignment',
  User: 'User',
  UserCompanyAssignment: 'UserCompanyAssignment',
  Company: 'Company',
  CompanyFormerName: 'CompanyFormerName',
  CompanyAddress: 'CompanyAddress',
  Contact: 'Contact',
  CompanyContact: 'CompanyContact',
  CompanyOfficer: 'CompanyOfficer',
  ShareCapital: 'ShareCapital',
  CompanyShareholder: 'CompanyShareholder',
  CompanyCharge: 'CompanyCharge',
  Document: 'Document',
  AuditLog: 'AuditLog',
  Connector: 'Connector',
  TenantConnectorAccess: 'TenantConnectorAccess',
  ConnectorUsageLog: 'ConnectorUsageLog',
  NoteTab: 'NoteTab',
  DocumentTemplate: 'DocumentTemplate',
  GeneratedDocument: 'GeneratedDocument',
  DocumentSection: 'DocumentSection',
  DocumentShare: 'DocumentShare',
  TenantLetterhead: 'TenantLetterhead',
  DocumentComment: 'DocumentComment',
  DocumentDraft: 'DocumentDraft',
  TemplatePartial: 'TemplatePartial',
  AiConversation: 'AiConversation',
  ProcessingDocument: 'ProcessingDocument',
  DocumentLink: 'DocumentLink',
  DocumentPage: 'DocumentPage',
  DocumentExtraction: 'DocumentExtraction',
  DocumentRevision: 'DocumentRevision',
  DocumentRevisionLineItem: 'DocumentRevisionLineItem',
  VendorAlias: 'VendorAlias',
  DuplicateDecision: 'DuplicateDecision',
  ProcessingAttempt: 'ProcessingAttempt',
  ProcessingCheckpoint: 'ProcessingCheckpoint',
  SplitPlan: 'SplitPlan',
  DocumentStateEvent: 'DocumentStateEvent',
  DocumentDerivedFile: 'DocumentDerivedFile',
  IdempotencyRecord: 'IdempotencyRecord',
  WebhookSubscription: 'WebhookSubscription',
  ExchangeRate: 'ExchangeRate',
  BankAccount: 'BankAccount',
  BankTransaction: 'BankTransaction',
  MatchGroup: 'MatchGroup',
  MatchGroupItem: 'MatchGroupItem',
  ReconciliationPeriod: 'ReconciliationPeriod',
  ClientPortalUser: 'ClientPortalUser',
  ClientRequest: 'ClientRequest',
  Communication: 'Communication',
  AccountingIntegration: 'AccountingIntegration',
  ExternalPosting: 'ExternalPosting',
  FieldMapping: 'FieldMapping',
  TenantBackup: 'TenantBackup',
  BackupSchedule: 'BackupSchedule'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "tenant" | "role" | "permission" | "rolePermission" | "userRoleAssignment" | "user" | "userCompanyAssignment" | "company" | "companyFormerName" | "companyAddress" | "contact" | "companyContact" | "companyOfficer" | "shareCapital" | "companyShareholder" | "companyCharge" | "document" | "auditLog" | "connector" | "tenantConnectorAccess" | "connectorUsageLog" | "noteTab" | "documentTemplate" | "generatedDocument" | "documentSection" | "documentShare" | "tenantLetterhead" | "documentComment" | "documentDraft" | "templatePartial" | "aiConversation" | "processingDocument" | "documentLink" | "documentPage" | "documentExtraction" | "documentRevision" | "documentRevisionLineItem" | "vendorAlias" | "duplicateDecision" | "processingAttempt" | "processingCheckpoint" | "splitPlan" | "documentStateEvent" | "documentDerivedFile" | "idempotencyRecord" | "webhookSubscription" | "exchangeRate" | "bankAccount" | "bankTransaction" | "matchGroup" | "matchGroupItem" | "reconciliationPeriod" | "clientPortalUser" | "clientRequest" | "communication" | "accountingIntegration" | "externalPosting" | "fieldMapping" | "tenantBackup" | "backupSchedule"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Tenant: {
      payload: Prisma.$TenantPayload<ExtArgs>
      fields: Prisma.TenantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findFirst: {
          args: Prisma.TenantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findMany: {
          args: Prisma.TenantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        create: {
          args: Prisma.TenantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        createMany: {
          args: Prisma.TenantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        delete: {
          args: Prisma.TenantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        update: {
          args: Prisma.TenantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        deleteMany: {
          args: Prisma.TenantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        upsert: {
          args: Prisma.TenantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        aggregate: {
          args: Prisma.TenantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenant>
        }
        groupBy: {
          args: Prisma.TenantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantCountAggregateOutputType> | number
        }
      }
    }
    Role: {
      payload: Prisma.$RolePayload<ExtArgs>
      fields: Prisma.RoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findFirst: {
          args: Prisma.RoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findMany: {
          args: Prisma.RoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        create: {
          args: Prisma.RoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        createMany: {
          args: Prisma.RoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        delete: {
          args: Prisma.RoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        update: {
          args: Prisma.RoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        deleteMany: {
          args: Prisma.RoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        upsert: {
          args: Prisma.RoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        aggregate: {
          args: Prisma.RoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRole>
        }
        groupBy: {
          args: Prisma.RoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.RoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleCountAggregateOutputType> | number
        }
      }
    }
    Permission: {
      payload: Prisma.$PermissionPayload<ExtArgs>
      fields: Prisma.PermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        findFirst: {
          args: Prisma.PermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        findMany: {
          args: Prisma.PermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        create: {
          args: Prisma.PermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        createMany: {
          args: Prisma.PermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        delete: {
          args: Prisma.PermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        update: {
          args: Prisma.PermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        deleteMany: {
          args: Prisma.PermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        upsert: {
          args: Prisma.PermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        aggregate: {
          args: Prisma.PermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePermission>
        }
        groupBy: {
          args: Prisma.PermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionCountAggregateOutputType> | number
        }
      }
    }
    RolePermission: {
      payload: Prisma.$RolePermissionPayload<ExtArgs>
      fields: Prisma.RolePermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        findFirst: {
          args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        findMany: {
          args: Prisma.RolePermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        create: {
          args: Prisma.RolePermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        createMany: {
          args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        delete: {
          args: Prisma.RolePermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        update: {
          args: Prisma.RolePermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        deleteMany: {
          args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        upsert: {
          args: Prisma.RolePermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        aggregate: {
          args: Prisma.RolePermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRolePermission>
        }
        groupBy: {
          args: Prisma.RolePermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolePermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.RolePermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolePermissionCountAggregateOutputType> | number
        }
      }
    }
    UserRoleAssignment: {
      payload: Prisma.$UserRoleAssignmentPayload<ExtArgs>
      fields: Prisma.UserRoleAssignmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserRoleAssignmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserRoleAssignmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
        }
        findFirst: {
          args: Prisma.UserRoleAssignmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserRoleAssignmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
        }
        findMany: {
          args: Prisma.UserRoleAssignmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>[]
        }
        create: {
          args: Prisma.UserRoleAssignmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
        }
        createMany: {
          args: Prisma.UserRoleAssignmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserRoleAssignmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>[]
        }
        delete: {
          args: Prisma.UserRoleAssignmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
        }
        update: {
          args: Prisma.UserRoleAssignmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
        }
        deleteMany: {
          args: Prisma.UserRoleAssignmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserRoleAssignmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserRoleAssignmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>[]
        }
        upsert: {
          args: Prisma.UserRoleAssignmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
        }
        aggregate: {
          args: Prisma.UserRoleAssignmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserRoleAssignment>
        }
        groupBy: {
          args: Prisma.UserRoleAssignmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRoleAssignmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserRoleAssignmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRoleAssignmentCountAggregateOutputType> | number
        }
      }
    }
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    UserCompanyAssignment: {
      payload: Prisma.$UserCompanyAssignmentPayload<ExtArgs>
      fields: Prisma.UserCompanyAssignmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserCompanyAssignmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompanyAssignmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserCompanyAssignmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompanyAssignmentPayload>
        }
        findFirst: {
          args: Prisma.UserCompanyAssignmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompanyAssignmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserCompanyAssignmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompanyAssignmentPayload>
        }
        findMany: {
          args: Prisma.UserCompanyAssignmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompanyAssignmentPayload>[]
        }
        create: {
          args: Prisma.UserCompanyAssignmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompanyAssignmentPayload>
        }
        createMany: {
          args: Prisma.UserCompanyAssignmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCompanyAssignmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompanyAssignmentPayload>[]
        }
        delete: {
          args: Prisma.UserCompanyAssignmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompanyAssignmentPayload>
        }
        update: {
          args: Prisma.UserCompanyAssignmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompanyAssignmentPayload>
        }
        deleteMany: {
          args: Prisma.UserCompanyAssignmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserCompanyAssignmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserCompanyAssignmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompanyAssignmentPayload>[]
        }
        upsert: {
          args: Prisma.UserCompanyAssignmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompanyAssignmentPayload>
        }
        aggregate: {
          args: Prisma.UserCompanyAssignmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserCompanyAssignment>
        }
        groupBy: {
          args: Prisma.UserCompanyAssignmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCompanyAssignmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCompanyAssignmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCompanyAssignmentCountAggregateOutputType> | number
        }
      }
    }
    Company: {
      payload: Prisma.$CompanyPayload<ExtArgs>
      fields: Prisma.CompanyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        findFirst: {
          args: Prisma.CompanyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        findMany: {
          args: Prisma.CompanyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        create: {
          args: Prisma.CompanyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        createMany: {
          args: Prisma.CompanyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        delete: {
          args: Prisma.CompanyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        update: {
          args: Prisma.CompanyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        deleteMany: {
          args: Prisma.CompanyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        upsert: {
          args: Prisma.CompanyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        aggregate: {
          args: Prisma.CompanyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompany>
        }
        groupBy: {
          args: Prisma.CompanyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyCountAggregateOutputType> | number
        }
      }
    }
    CompanyFormerName: {
      payload: Prisma.$CompanyFormerNamePayload<ExtArgs>
      fields: Prisma.CompanyFormerNameFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyFormerNameFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFormerNamePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyFormerNameFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFormerNamePayload>
        }
        findFirst: {
          args: Prisma.CompanyFormerNameFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFormerNamePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyFormerNameFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFormerNamePayload>
        }
        findMany: {
          args: Prisma.CompanyFormerNameFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFormerNamePayload>[]
        }
        create: {
          args: Prisma.CompanyFormerNameCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFormerNamePayload>
        }
        createMany: {
          args: Prisma.CompanyFormerNameCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyFormerNameCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFormerNamePayload>[]
        }
        delete: {
          args: Prisma.CompanyFormerNameDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFormerNamePayload>
        }
        update: {
          args: Prisma.CompanyFormerNameUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFormerNamePayload>
        }
        deleteMany: {
          args: Prisma.CompanyFormerNameDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyFormerNameUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyFormerNameUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFormerNamePayload>[]
        }
        upsert: {
          args: Prisma.CompanyFormerNameUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyFormerNamePayload>
        }
        aggregate: {
          args: Prisma.CompanyFormerNameAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyFormerName>
        }
        groupBy: {
          args: Prisma.CompanyFormerNameGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyFormerNameGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyFormerNameCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyFormerNameCountAggregateOutputType> | number
        }
      }
    }
    CompanyAddress: {
      payload: Prisma.$CompanyAddressPayload<ExtArgs>
      fields: Prisma.CompanyAddressFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyAddressFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyAddressFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>
        }
        findFirst: {
          args: Prisma.CompanyAddressFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyAddressFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>
        }
        findMany: {
          args: Prisma.CompanyAddressFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>[]
        }
        create: {
          args: Prisma.CompanyAddressCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>
        }
        createMany: {
          args: Prisma.CompanyAddressCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyAddressCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>[]
        }
        delete: {
          args: Prisma.CompanyAddressDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>
        }
        update: {
          args: Prisma.CompanyAddressUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>
        }
        deleteMany: {
          args: Prisma.CompanyAddressDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyAddressUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyAddressUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>[]
        }
        upsert: {
          args: Prisma.CompanyAddressUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyAddressPayload>
        }
        aggregate: {
          args: Prisma.CompanyAddressAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyAddress>
        }
        groupBy: {
          args: Prisma.CompanyAddressGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyAddressGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyAddressCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyAddressCountAggregateOutputType> | number
        }
      }
    }
    Contact: {
      payload: Prisma.$ContactPayload<ExtArgs>
      fields: Prisma.ContactFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ContactFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>
        }
        findFirst: {
          args: Prisma.ContactFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>
        }
        findMany: {
          args: Prisma.ContactFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>[]
        }
        create: {
          args: Prisma.ContactCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>
        }
        createMany: {
          args: Prisma.ContactCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>[]
        }
        delete: {
          args: Prisma.ContactDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>
        }
        update: {
          args: Prisma.ContactUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>
        }
        deleteMany: {
          args: Prisma.ContactDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ContactUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>[]
        }
        upsert: {
          args: Prisma.ContactUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>
        }
        aggregate: {
          args: Prisma.ContactAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateContact>
        }
        groupBy: {
          args: Prisma.ContactGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContactGroupByOutputType>[]
        }
        count: {
          args: Prisma.ContactCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContactCountAggregateOutputType> | number
        }
      }
    }
    CompanyContact: {
      payload: Prisma.$CompanyContactPayload<ExtArgs>
      fields: Prisma.CompanyContactFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyContactFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyContactPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyContactFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyContactPayload>
        }
        findFirst: {
          args: Prisma.CompanyContactFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyContactPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyContactFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyContactPayload>
        }
        findMany: {
          args: Prisma.CompanyContactFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyContactPayload>[]
        }
        create: {
          args: Prisma.CompanyContactCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyContactPayload>
        }
        createMany: {
          args: Prisma.CompanyContactCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyContactCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyContactPayload>[]
        }
        delete: {
          args: Prisma.CompanyContactDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyContactPayload>
        }
        update: {
          args: Prisma.CompanyContactUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyContactPayload>
        }
        deleteMany: {
          args: Prisma.CompanyContactDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyContactUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyContactUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyContactPayload>[]
        }
        upsert: {
          args: Prisma.CompanyContactUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyContactPayload>
        }
        aggregate: {
          args: Prisma.CompanyContactAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyContact>
        }
        groupBy: {
          args: Prisma.CompanyContactGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyContactGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyContactCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyContactCountAggregateOutputType> | number
        }
      }
    }
    CompanyOfficer: {
      payload: Prisma.$CompanyOfficerPayload<ExtArgs>
      fields: Prisma.CompanyOfficerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyOfficerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOfficerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyOfficerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOfficerPayload>
        }
        findFirst: {
          args: Prisma.CompanyOfficerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOfficerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyOfficerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOfficerPayload>
        }
        findMany: {
          args: Prisma.CompanyOfficerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOfficerPayload>[]
        }
        create: {
          args: Prisma.CompanyOfficerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOfficerPayload>
        }
        createMany: {
          args: Prisma.CompanyOfficerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyOfficerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOfficerPayload>[]
        }
        delete: {
          args: Prisma.CompanyOfficerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOfficerPayload>
        }
        update: {
          args: Prisma.CompanyOfficerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOfficerPayload>
        }
        deleteMany: {
          args: Prisma.CompanyOfficerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyOfficerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyOfficerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOfficerPayload>[]
        }
        upsert: {
          args: Prisma.CompanyOfficerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOfficerPayload>
        }
        aggregate: {
          args: Prisma.CompanyOfficerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyOfficer>
        }
        groupBy: {
          args: Prisma.CompanyOfficerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyOfficerGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyOfficerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyOfficerCountAggregateOutputType> | number
        }
      }
    }
    ShareCapital: {
      payload: Prisma.$ShareCapitalPayload<ExtArgs>
      fields: Prisma.ShareCapitalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ShareCapitalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShareCapitalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ShareCapitalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShareCapitalPayload>
        }
        findFirst: {
          args: Prisma.ShareCapitalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShareCapitalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ShareCapitalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShareCapitalPayload>
        }
        findMany: {
          args: Prisma.ShareCapitalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShareCapitalPayload>[]
        }
        create: {
          args: Prisma.ShareCapitalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShareCapitalPayload>
        }
        createMany: {
          args: Prisma.ShareCapitalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ShareCapitalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShareCapitalPayload>[]
        }
        delete: {
          args: Prisma.ShareCapitalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShareCapitalPayload>
        }
        update: {
          args: Prisma.ShareCapitalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShareCapitalPayload>
        }
        deleteMany: {
          args: Prisma.ShareCapitalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ShareCapitalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ShareCapitalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShareCapitalPayload>[]
        }
        upsert: {
          args: Prisma.ShareCapitalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShareCapitalPayload>
        }
        aggregate: {
          args: Prisma.ShareCapitalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateShareCapital>
        }
        groupBy: {
          args: Prisma.ShareCapitalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ShareCapitalGroupByOutputType>[]
        }
        count: {
          args: Prisma.ShareCapitalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ShareCapitalCountAggregateOutputType> | number
        }
      }
    }
    CompanyShareholder: {
      payload: Prisma.$CompanyShareholderPayload<ExtArgs>
      fields: Prisma.CompanyShareholderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyShareholderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyShareholderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyShareholderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>
        }
        findFirst: {
          args: Prisma.CompanyShareholderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyShareholderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyShareholderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>
        }
        findMany: {
          args: Prisma.CompanyShareholderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>[]
        }
        create: {
          args: Prisma.CompanyShareholderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>
        }
        createMany: {
          args: Prisma.CompanyShareholderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyShareholderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>[]
        }
        delete: {
          args: Prisma.CompanyShareholderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>
        }
        update: {
          args: Prisma.CompanyShareholderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>
        }
        deleteMany: {
          args: Prisma.CompanyShareholderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyShareholderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyShareholderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>[]
        }
        upsert: {
          args: Prisma.CompanyShareholderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>
        }
        aggregate: {
          args: Prisma.CompanyShareholderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyShareholder>
        }
        groupBy: {
          args: Prisma.CompanyShareholderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyShareholderGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyShareholderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyShareholderCountAggregateOutputType> | number
        }
      }
    }
    CompanyCharge: {
      payload: Prisma.$CompanyChargePayload<ExtArgs>
      fields: Prisma.CompanyChargeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyChargeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyChargePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyChargeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyChargePayload>
        }
        findFirst: {
          args: Prisma.CompanyChargeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyChargePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyChargeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyChargePayload>
        }
        findMany: {
          args: Prisma.CompanyChargeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyChargePayload>[]
        }
        create: {
          args: Prisma.CompanyChargeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyChargePayload>
        }
        createMany: {
          args: Prisma.CompanyChargeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyChargeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyChargePayload>[]
        }
        delete: {
          args: Prisma.CompanyChargeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyChargePayload>
        }
        update: {
          args: Prisma.CompanyChargeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyChargePayload>
        }
        deleteMany: {
          args: Prisma.CompanyChargeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyChargeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyChargeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyChargePayload>[]
        }
        upsert: {
          args: Prisma.CompanyChargeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyChargePayload>
        }
        aggregate: {
          args: Prisma.CompanyChargeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyCharge>
        }
        groupBy: {
          args: Prisma.CompanyChargeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyChargeGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyChargeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyChargeCountAggregateOutputType> | number
        }
      }
    }
    Document: {
      payload: Prisma.$DocumentPayload<ExtArgs>
      fields: Prisma.DocumentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        findFirst: {
          args: Prisma.DocumentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        findMany: {
          args: Prisma.DocumentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[]
        }
        create: {
          args: Prisma.DocumentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        createMany: {
          args: Prisma.DocumentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[]
        }
        delete: {
          args: Prisma.DocumentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        update: {
          args: Prisma.DocumentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        deleteMany: {
          args: Prisma.DocumentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[]
        }
        upsert: {
          args: Prisma.DocumentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        aggregate: {
          args: Prisma.DocumentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocument>
        }
        groupBy: {
          args: Prisma.DocumentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentCountAggregateOutputType> | number
        }
      }
    }
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>
      fields: Prisma.AuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>
        }
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType> | number
        }
      }
    }
    Connector: {
      payload: Prisma.$ConnectorPayload<ExtArgs>
      fields: Prisma.ConnectorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConnectorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConnectorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorPayload>
        }
        findFirst: {
          args: Prisma.ConnectorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConnectorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorPayload>
        }
        findMany: {
          args: Prisma.ConnectorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorPayload>[]
        }
        create: {
          args: Prisma.ConnectorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorPayload>
        }
        createMany: {
          args: Prisma.ConnectorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConnectorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorPayload>[]
        }
        delete: {
          args: Prisma.ConnectorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorPayload>
        }
        update: {
          args: Prisma.ConnectorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorPayload>
        }
        deleteMany: {
          args: Prisma.ConnectorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConnectorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConnectorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorPayload>[]
        }
        upsert: {
          args: Prisma.ConnectorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorPayload>
        }
        aggregate: {
          args: Prisma.ConnectorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConnector>
        }
        groupBy: {
          args: Prisma.ConnectorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConnectorGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConnectorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConnectorCountAggregateOutputType> | number
        }
      }
    }
    TenantConnectorAccess: {
      payload: Prisma.$TenantConnectorAccessPayload<ExtArgs>
      fields: Prisma.TenantConnectorAccessFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantConnectorAccessFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantConnectorAccessPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantConnectorAccessFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantConnectorAccessPayload>
        }
        findFirst: {
          args: Prisma.TenantConnectorAccessFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantConnectorAccessPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantConnectorAccessFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantConnectorAccessPayload>
        }
        findMany: {
          args: Prisma.TenantConnectorAccessFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantConnectorAccessPayload>[]
        }
        create: {
          args: Prisma.TenantConnectorAccessCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantConnectorAccessPayload>
        }
        createMany: {
          args: Prisma.TenantConnectorAccessCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantConnectorAccessCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantConnectorAccessPayload>[]
        }
        delete: {
          args: Prisma.TenantConnectorAccessDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantConnectorAccessPayload>
        }
        update: {
          args: Prisma.TenantConnectorAccessUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantConnectorAccessPayload>
        }
        deleteMany: {
          args: Prisma.TenantConnectorAccessDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantConnectorAccessUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantConnectorAccessUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantConnectorAccessPayload>[]
        }
        upsert: {
          args: Prisma.TenantConnectorAccessUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantConnectorAccessPayload>
        }
        aggregate: {
          args: Prisma.TenantConnectorAccessAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantConnectorAccess>
        }
        groupBy: {
          args: Prisma.TenantConnectorAccessGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantConnectorAccessGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantConnectorAccessCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantConnectorAccessCountAggregateOutputType> | number
        }
      }
    }
    ConnectorUsageLog: {
      payload: Prisma.$ConnectorUsageLogPayload<ExtArgs>
      fields: Prisma.ConnectorUsageLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConnectorUsageLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorUsageLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConnectorUsageLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorUsageLogPayload>
        }
        findFirst: {
          args: Prisma.ConnectorUsageLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorUsageLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConnectorUsageLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorUsageLogPayload>
        }
        findMany: {
          args: Prisma.ConnectorUsageLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorUsageLogPayload>[]
        }
        create: {
          args: Prisma.ConnectorUsageLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorUsageLogPayload>
        }
        createMany: {
          args: Prisma.ConnectorUsageLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConnectorUsageLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorUsageLogPayload>[]
        }
        delete: {
          args: Prisma.ConnectorUsageLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorUsageLogPayload>
        }
        update: {
          args: Prisma.ConnectorUsageLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorUsageLogPayload>
        }
        deleteMany: {
          args: Prisma.ConnectorUsageLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConnectorUsageLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConnectorUsageLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorUsageLogPayload>[]
        }
        upsert: {
          args: Prisma.ConnectorUsageLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConnectorUsageLogPayload>
        }
        aggregate: {
          args: Prisma.ConnectorUsageLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConnectorUsageLog>
        }
        groupBy: {
          args: Prisma.ConnectorUsageLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConnectorUsageLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConnectorUsageLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConnectorUsageLogCountAggregateOutputType> | number
        }
      }
    }
    NoteTab: {
      payload: Prisma.$NoteTabPayload<ExtArgs>
      fields: Prisma.NoteTabFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NoteTabFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteTabPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NoteTabFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteTabPayload>
        }
        findFirst: {
          args: Prisma.NoteTabFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteTabPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NoteTabFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteTabPayload>
        }
        findMany: {
          args: Prisma.NoteTabFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteTabPayload>[]
        }
        create: {
          args: Prisma.NoteTabCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteTabPayload>
        }
        createMany: {
          args: Prisma.NoteTabCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NoteTabCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteTabPayload>[]
        }
        delete: {
          args: Prisma.NoteTabDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteTabPayload>
        }
        update: {
          args: Prisma.NoteTabUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteTabPayload>
        }
        deleteMany: {
          args: Prisma.NoteTabDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NoteTabUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NoteTabUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteTabPayload>[]
        }
        upsert: {
          args: Prisma.NoteTabUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteTabPayload>
        }
        aggregate: {
          args: Prisma.NoteTabAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNoteTab>
        }
        groupBy: {
          args: Prisma.NoteTabGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NoteTabGroupByOutputType>[]
        }
        count: {
          args: Prisma.NoteTabCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NoteTabCountAggregateOutputType> | number
        }
      }
    }
    DocumentTemplate: {
      payload: Prisma.$DocumentTemplatePayload<ExtArgs>
      fields: Prisma.DocumentTemplateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentTemplateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentTemplateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
        }
        findFirst: {
          args: Prisma.DocumentTemplateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentTemplateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
        }
        findMany: {
          args: Prisma.DocumentTemplateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>[]
        }
        create: {
          args: Prisma.DocumentTemplateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
        }
        createMany: {
          args: Prisma.DocumentTemplateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentTemplateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>[]
        }
        delete: {
          args: Prisma.DocumentTemplateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
        }
        update: {
          args: Prisma.DocumentTemplateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
        }
        deleteMany: {
          args: Prisma.DocumentTemplateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentTemplateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentTemplateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>[]
        }
        upsert: {
          args: Prisma.DocumentTemplateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
        }
        aggregate: {
          args: Prisma.DocumentTemplateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentTemplate>
        }
        groupBy: {
          args: Prisma.DocumentTemplateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentTemplateGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentTemplateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentTemplateCountAggregateOutputType> | number
        }
      }
    }
    GeneratedDocument: {
      payload: Prisma.$GeneratedDocumentPayload<ExtArgs>
      fields: Prisma.GeneratedDocumentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GeneratedDocumentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GeneratedDocumentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>
        }
        findFirst: {
          args: Prisma.GeneratedDocumentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GeneratedDocumentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>
        }
        findMany: {
          args: Prisma.GeneratedDocumentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>[]
        }
        create: {
          args: Prisma.GeneratedDocumentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>
        }
        createMany: {
          args: Prisma.GeneratedDocumentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GeneratedDocumentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>[]
        }
        delete: {
          args: Prisma.GeneratedDocumentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>
        }
        update: {
          args: Prisma.GeneratedDocumentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>
        }
        deleteMany: {
          args: Prisma.GeneratedDocumentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GeneratedDocumentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GeneratedDocumentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>[]
        }
        upsert: {
          args: Prisma.GeneratedDocumentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GeneratedDocumentPayload>
        }
        aggregate: {
          args: Prisma.GeneratedDocumentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGeneratedDocument>
        }
        groupBy: {
          args: Prisma.GeneratedDocumentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GeneratedDocumentGroupByOutputType>[]
        }
        count: {
          args: Prisma.GeneratedDocumentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GeneratedDocumentCountAggregateOutputType> | number
        }
      }
    }
    DocumentSection: {
      payload: Prisma.$DocumentSectionPayload<ExtArgs>
      fields: Prisma.DocumentSectionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentSectionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSectionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentSectionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSectionPayload>
        }
        findFirst: {
          args: Prisma.DocumentSectionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSectionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentSectionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSectionPayload>
        }
        findMany: {
          args: Prisma.DocumentSectionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSectionPayload>[]
        }
        create: {
          args: Prisma.DocumentSectionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSectionPayload>
        }
        createMany: {
          args: Prisma.DocumentSectionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentSectionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSectionPayload>[]
        }
        delete: {
          args: Prisma.DocumentSectionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSectionPayload>
        }
        update: {
          args: Prisma.DocumentSectionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSectionPayload>
        }
        deleteMany: {
          args: Prisma.DocumentSectionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentSectionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentSectionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSectionPayload>[]
        }
        upsert: {
          args: Prisma.DocumentSectionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSectionPayload>
        }
        aggregate: {
          args: Prisma.DocumentSectionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentSection>
        }
        groupBy: {
          args: Prisma.DocumentSectionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentSectionGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentSectionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentSectionCountAggregateOutputType> | number
        }
      }
    }
    DocumentShare: {
      payload: Prisma.$DocumentSharePayload<ExtArgs>
      fields: Prisma.DocumentShareFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentShareFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSharePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentShareFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSharePayload>
        }
        findFirst: {
          args: Prisma.DocumentShareFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSharePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentShareFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSharePayload>
        }
        findMany: {
          args: Prisma.DocumentShareFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSharePayload>[]
        }
        create: {
          args: Prisma.DocumentShareCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSharePayload>
        }
        createMany: {
          args: Prisma.DocumentShareCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentShareCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSharePayload>[]
        }
        delete: {
          args: Prisma.DocumentShareDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSharePayload>
        }
        update: {
          args: Prisma.DocumentShareUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSharePayload>
        }
        deleteMany: {
          args: Prisma.DocumentShareDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentShareUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentShareUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSharePayload>[]
        }
        upsert: {
          args: Prisma.DocumentShareUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentSharePayload>
        }
        aggregate: {
          args: Prisma.DocumentShareAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentShare>
        }
        groupBy: {
          args: Prisma.DocumentShareGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentShareGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentShareCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentShareCountAggregateOutputType> | number
        }
      }
    }
    TenantLetterhead: {
      payload: Prisma.$TenantLetterheadPayload<ExtArgs>
      fields: Prisma.TenantLetterheadFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantLetterheadFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLetterheadPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantLetterheadFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLetterheadPayload>
        }
        findFirst: {
          args: Prisma.TenantLetterheadFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLetterheadPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantLetterheadFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLetterheadPayload>
        }
        findMany: {
          args: Prisma.TenantLetterheadFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLetterheadPayload>[]
        }
        create: {
          args: Prisma.TenantLetterheadCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLetterheadPayload>
        }
        createMany: {
          args: Prisma.TenantLetterheadCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantLetterheadCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLetterheadPayload>[]
        }
        delete: {
          args: Prisma.TenantLetterheadDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLetterheadPayload>
        }
        update: {
          args: Prisma.TenantLetterheadUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLetterheadPayload>
        }
        deleteMany: {
          args: Prisma.TenantLetterheadDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantLetterheadUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantLetterheadUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLetterheadPayload>[]
        }
        upsert: {
          args: Prisma.TenantLetterheadUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLetterheadPayload>
        }
        aggregate: {
          args: Prisma.TenantLetterheadAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantLetterhead>
        }
        groupBy: {
          args: Prisma.TenantLetterheadGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantLetterheadGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantLetterheadCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantLetterheadCountAggregateOutputType> | number
        }
      }
    }
    DocumentComment: {
      payload: Prisma.$DocumentCommentPayload<ExtArgs>
      fields: Prisma.DocumentCommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentCommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentCommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentCommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
        }
        findFirst: {
          args: Prisma.DocumentCommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentCommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentCommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
        }
        findMany: {
          args: Prisma.DocumentCommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentCommentPayload>[]
        }
        create: {
          args: Prisma.DocumentCommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
        }
        createMany: {
          args: Prisma.DocumentCommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentCommentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentCommentPayload>[]
        }
        delete: {
          args: Prisma.DocumentCommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
        }
        update: {
          args: Prisma.DocumentCommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
        }
        deleteMany: {
          args: Prisma.DocumentCommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentCommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentCommentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentCommentPayload>[]
        }
        upsert: {
          args: Prisma.DocumentCommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
        }
        aggregate: {
          args: Prisma.DocumentCommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentComment>
        }
        groupBy: {
          args: Prisma.DocumentCommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentCommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentCommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentCommentCountAggregateOutputType> | number
        }
      }
    }
    DocumentDraft: {
      payload: Prisma.$DocumentDraftPayload<ExtArgs>
      fields: Prisma.DocumentDraftFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentDraftFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDraftPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentDraftFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDraftPayload>
        }
        findFirst: {
          args: Prisma.DocumentDraftFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDraftPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentDraftFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDraftPayload>
        }
        findMany: {
          args: Prisma.DocumentDraftFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDraftPayload>[]
        }
        create: {
          args: Prisma.DocumentDraftCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDraftPayload>
        }
        createMany: {
          args: Prisma.DocumentDraftCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentDraftCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDraftPayload>[]
        }
        delete: {
          args: Prisma.DocumentDraftDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDraftPayload>
        }
        update: {
          args: Prisma.DocumentDraftUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDraftPayload>
        }
        deleteMany: {
          args: Prisma.DocumentDraftDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentDraftUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentDraftUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDraftPayload>[]
        }
        upsert: {
          args: Prisma.DocumentDraftUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDraftPayload>
        }
        aggregate: {
          args: Prisma.DocumentDraftAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentDraft>
        }
        groupBy: {
          args: Prisma.DocumentDraftGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentDraftGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentDraftCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentDraftCountAggregateOutputType> | number
        }
      }
    }
    TemplatePartial: {
      payload: Prisma.$TemplatePartialPayload<ExtArgs>
      fields: Prisma.TemplatePartialFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TemplatePartialFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePartialPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TemplatePartialFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePartialPayload>
        }
        findFirst: {
          args: Prisma.TemplatePartialFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePartialPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TemplatePartialFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePartialPayload>
        }
        findMany: {
          args: Prisma.TemplatePartialFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePartialPayload>[]
        }
        create: {
          args: Prisma.TemplatePartialCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePartialPayload>
        }
        createMany: {
          args: Prisma.TemplatePartialCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TemplatePartialCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePartialPayload>[]
        }
        delete: {
          args: Prisma.TemplatePartialDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePartialPayload>
        }
        update: {
          args: Prisma.TemplatePartialUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePartialPayload>
        }
        deleteMany: {
          args: Prisma.TemplatePartialDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TemplatePartialUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TemplatePartialUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePartialPayload>[]
        }
        upsert: {
          args: Prisma.TemplatePartialUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplatePartialPayload>
        }
        aggregate: {
          args: Prisma.TemplatePartialAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTemplatePartial>
        }
        groupBy: {
          args: Prisma.TemplatePartialGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TemplatePartialGroupByOutputType>[]
        }
        count: {
          args: Prisma.TemplatePartialCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TemplatePartialCountAggregateOutputType> | number
        }
      }
    }
    AiConversation: {
      payload: Prisma.$AiConversationPayload<ExtArgs>
      fields: Prisma.AiConversationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiConversationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiConversationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>
        }
        findFirst: {
          args: Prisma.AiConversationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiConversationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>
        }
        findMany: {
          args: Prisma.AiConversationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>[]
        }
        create: {
          args: Prisma.AiConversationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>
        }
        createMany: {
          args: Prisma.AiConversationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiConversationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>[]
        }
        delete: {
          args: Prisma.AiConversationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>
        }
        update: {
          args: Prisma.AiConversationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>
        }
        deleteMany: {
          args: Prisma.AiConversationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiConversationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiConversationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>[]
        }
        upsert: {
          args: Prisma.AiConversationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>
        }
        aggregate: {
          args: Prisma.AiConversationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiConversation>
        }
        groupBy: {
          args: Prisma.AiConversationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConversationGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiConversationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConversationCountAggregateOutputType> | number
        }
      }
    }
    ProcessingDocument: {
      payload: Prisma.$ProcessingDocumentPayload<ExtArgs>
      fields: Prisma.ProcessingDocumentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProcessingDocumentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingDocumentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProcessingDocumentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingDocumentPayload>
        }
        findFirst: {
          args: Prisma.ProcessingDocumentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingDocumentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProcessingDocumentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingDocumentPayload>
        }
        findMany: {
          args: Prisma.ProcessingDocumentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingDocumentPayload>[]
        }
        create: {
          args: Prisma.ProcessingDocumentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingDocumentPayload>
        }
        createMany: {
          args: Prisma.ProcessingDocumentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProcessingDocumentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingDocumentPayload>[]
        }
        delete: {
          args: Prisma.ProcessingDocumentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingDocumentPayload>
        }
        update: {
          args: Prisma.ProcessingDocumentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingDocumentPayload>
        }
        deleteMany: {
          args: Prisma.ProcessingDocumentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProcessingDocumentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProcessingDocumentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingDocumentPayload>[]
        }
        upsert: {
          args: Prisma.ProcessingDocumentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingDocumentPayload>
        }
        aggregate: {
          args: Prisma.ProcessingDocumentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProcessingDocument>
        }
        groupBy: {
          args: Prisma.ProcessingDocumentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProcessingDocumentGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProcessingDocumentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProcessingDocumentCountAggregateOutputType> | number
        }
      }
    }
    DocumentLink: {
      payload: Prisma.$DocumentLinkPayload<ExtArgs>
      fields: Prisma.DocumentLinkFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentLinkFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentLinkPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentLinkFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentLinkPayload>
        }
        findFirst: {
          args: Prisma.DocumentLinkFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentLinkPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentLinkFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentLinkPayload>
        }
        findMany: {
          args: Prisma.DocumentLinkFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentLinkPayload>[]
        }
        create: {
          args: Prisma.DocumentLinkCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentLinkPayload>
        }
        createMany: {
          args: Prisma.DocumentLinkCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentLinkCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentLinkPayload>[]
        }
        delete: {
          args: Prisma.DocumentLinkDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentLinkPayload>
        }
        update: {
          args: Prisma.DocumentLinkUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentLinkPayload>
        }
        deleteMany: {
          args: Prisma.DocumentLinkDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentLinkUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentLinkUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentLinkPayload>[]
        }
        upsert: {
          args: Prisma.DocumentLinkUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentLinkPayload>
        }
        aggregate: {
          args: Prisma.DocumentLinkAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentLink>
        }
        groupBy: {
          args: Prisma.DocumentLinkGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentLinkGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentLinkCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentLinkCountAggregateOutputType> | number
        }
      }
    }
    DocumentPage: {
      payload: Prisma.$DocumentPagePayload<ExtArgs>
      fields: Prisma.DocumentPageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentPageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentPageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPagePayload>
        }
        findFirst: {
          args: Prisma.DocumentPageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentPageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPagePayload>
        }
        findMany: {
          args: Prisma.DocumentPageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPagePayload>[]
        }
        create: {
          args: Prisma.DocumentPageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPagePayload>
        }
        createMany: {
          args: Prisma.DocumentPageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentPageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPagePayload>[]
        }
        delete: {
          args: Prisma.DocumentPageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPagePayload>
        }
        update: {
          args: Prisma.DocumentPageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPagePayload>
        }
        deleteMany: {
          args: Prisma.DocumentPageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentPageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentPageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPagePayload>[]
        }
        upsert: {
          args: Prisma.DocumentPageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPagePayload>
        }
        aggregate: {
          args: Prisma.DocumentPageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentPage>
        }
        groupBy: {
          args: Prisma.DocumentPageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentPageGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentPageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentPageCountAggregateOutputType> | number
        }
      }
    }
    DocumentExtraction: {
      payload: Prisma.$DocumentExtractionPayload<ExtArgs>
      fields: Prisma.DocumentExtractionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentExtractionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExtractionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentExtractionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExtractionPayload>
        }
        findFirst: {
          args: Prisma.DocumentExtractionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExtractionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentExtractionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExtractionPayload>
        }
        findMany: {
          args: Prisma.DocumentExtractionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExtractionPayload>[]
        }
        create: {
          args: Prisma.DocumentExtractionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExtractionPayload>
        }
        createMany: {
          args: Prisma.DocumentExtractionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentExtractionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExtractionPayload>[]
        }
        delete: {
          args: Prisma.DocumentExtractionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExtractionPayload>
        }
        update: {
          args: Prisma.DocumentExtractionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExtractionPayload>
        }
        deleteMany: {
          args: Prisma.DocumentExtractionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentExtractionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentExtractionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExtractionPayload>[]
        }
        upsert: {
          args: Prisma.DocumentExtractionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExtractionPayload>
        }
        aggregate: {
          args: Prisma.DocumentExtractionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentExtraction>
        }
        groupBy: {
          args: Prisma.DocumentExtractionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentExtractionGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentExtractionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentExtractionCountAggregateOutputType> | number
        }
      }
    }
    DocumentRevision: {
      payload: Prisma.$DocumentRevisionPayload<ExtArgs>
      fields: Prisma.DocumentRevisionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentRevisionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentRevisionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>
        }
        findFirst: {
          args: Prisma.DocumentRevisionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentRevisionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>
        }
        findMany: {
          args: Prisma.DocumentRevisionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>[]
        }
        create: {
          args: Prisma.DocumentRevisionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>
        }
        createMany: {
          args: Prisma.DocumentRevisionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentRevisionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>[]
        }
        delete: {
          args: Prisma.DocumentRevisionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>
        }
        update: {
          args: Prisma.DocumentRevisionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>
        }
        deleteMany: {
          args: Prisma.DocumentRevisionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentRevisionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentRevisionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>[]
        }
        upsert: {
          args: Prisma.DocumentRevisionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>
        }
        aggregate: {
          args: Prisma.DocumentRevisionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentRevision>
        }
        groupBy: {
          args: Prisma.DocumentRevisionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentRevisionGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentRevisionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentRevisionCountAggregateOutputType> | number
        }
      }
    }
    DocumentRevisionLineItem: {
      payload: Prisma.$DocumentRevisionLineItemPayload<ExtArgs>
      fields: Prisma.DocumentRevisionLineItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentRevisionLineItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionLineItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentRevisionLineItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionLineItemPayload>
        }
        findFirst: {
          args: Prisma.DocumentRevisionLineItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionLineItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentRevisionLineItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionLineItemPayload>
        }
        findMany: {
          args: Prisma.DocumentRevisionLineItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionLineItemPayload>[]
        }
        create: {
          args: Prisma.DocumentRevisionLineItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionLineItemPayload>
        }
        createMany: {
          args: Prisma.DocumentRevisionLineItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentRevisionLineItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionLineItemPayload>[]
        }
        delete: {
          args: Prisma.DocumentRevisionLineItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionLineItemPayload>
        }
        update: {
          args: Prisma.DocumentRevisionLineItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionLineItemPayload>
        }
        deleteMany: {
          args: Prisma.DocumentRevisionLineItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentRevisionLineItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentRevisionLineItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionLineItemPayload>[]
        }
        upsert: {
          args: Prisma.DocumentRevisionLineItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRevisionLineItemPayload>
        }
        aggregate: {
          args: Prisma.DocumentRevisionLineItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentRevisionLineItem>
        }
        groupBy: {
          args: Prisma.DocumentRevisionLineItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentRevisionLineItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentRevisionLineItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentRevisionLineItemCountAggregateOutputType> | number
        }
      }
    }
    VendorAlias: {
      payload: Prisma.$VendorAliasPayload<ExtArgs>
      fields: Prisma.VendorAliasFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VendorAliasFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorAliasPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VendorAliasFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorAliasPayload>
        }
        findFirst: {
          args: Prisma.VendorAliasFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorAliasPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VendorAliasFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorAliasPayload>
        }
        findMany: {
          args: Prisma.VendorAliasFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorAliasPayload>[]
        }
        create: {
          args: Prisma.VendorAliasCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorAliasPayload>
        }
        createMany: {
          args: Prisma.VendorAliasCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VendorAliasCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorAliasPayload>[]
        }
        delete: {
          args: Prisma.VendorAliasDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorAliasPayload>
        }
        update: {
          args: Prisma.VendorAliasUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorAliasPayload>
        }
        deleteMany: {
          args: Prisma.VendorAliasDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VendorAliasUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VendorAliasUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorAliasPayload>[]
        }
        upsert: {
          args: Prisma.VendorAliasUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorAliasPayload>
        }
        aggregate: {
          args: Prisma.VendorAliasAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVendorAlias>
        }
        groupBy: {
          args: Prisma.VendorAliasGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VendorAliasGroupByOutputType>[]
        }
        count: {
          args: Prisma.VendorAliasCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VendorAliasCountAggregateOutputType> | number
        }
      }
    }
    DuplicateDecision: {
      payload: Prisma.$DuplicateDecisionPayload<ExtArgs>
      fields: Prisma.DuplicateDecisionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DuplicateDecisionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DuplicateDecisionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DuplicateDecisionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DuplicateDecisionPayload>
        }
        findFirst: {
          args: Prisma.DuplicateDecisionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DuplicateDecisionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DuplicateDecisionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DuplicateDecisionPayload>
        }
        findMany: {
          args: Prisma.DuplicateDecisionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DuplicateDecisionPayload>[]
        }
        create: {
          args: Prisma.DuplicateDecisionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DuplicateDecisionPayload>
        }
        createMany: {
          args: Prisma.DuplicateDecisionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DuplicateDecisionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DuplicateDecisionPayload>[]
        }
        delete: {
          args: Prisma.DuplicateDecisionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DuplicateDecisionPayload>
        }
        update: {
          args: Prisma.DuplicateDecisionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DuplicateDecisionPayload>
        }
        deleteMany: {
          args: Prisma.DuplicateDecisionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DuplicateDecisionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DuplicateDecisionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DuplicateDecisionPayload>[]
        }
        upsert: {
          args: Prisma.DuplicateDecisionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DuplicateDecisionPayload>
        }
        aggregate: {
          args: Prisma.DuplicateDecisionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDuplicateDecision>
        }
        groupBy: {
          args: Prisma.DuplicateDecisionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DuplicateDecisionGroupByOutputType>[]
        }
        count: {
          args: Prisma.DuplicateDecisionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DuplicateDecisionCountAggregateOutputType> | number
        }
      }
    }
    ProcessingAttempt: {
      payload: Prisma.$ProcessingAttemptPayload<ExtArgs>
      fields: Prisma.ProcessingAttemptFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProcessingAttemptFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingAttemptPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProcessingAttemptFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingAttemptPayload>
        }
        findFirst: {
          args: Prisma.ProcessingAttemptFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingAttemptPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProcessingAttemptFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingAttemptPayload>
        }
        findMany: {
          args: Prisma.ProcessingAttemptFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingAttemptPayload>[]
        }
        create: {
          args: Prisma.ProcessingAttemptCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingAttemptPayload>
        }
        createMany: {
          args: Prisma.ProcessingAttemptCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProcessingAttemptCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingAttemptPayload>[]
        }
        delete: {
          args: Prisma.ProcessingAttemptDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingAttemptPayload>
        }
        update: {
          args: Prisma.ProcessingAttemptUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingAttemptPayload>
        }
        deleteMany: {
          args: Prisma.ProcessingAttemptDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProcessingAttemptUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProcessingAttemptUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingAttemptPayload>[]
        }
        upsert: {
          args: Prisma.ProcessingAttemptUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingAttemptPayload>
        }
        aggregate: {
          args: Prisma.ProcessingAttemptAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProcessingAttempt>
        }
        groupBy: {
          args: Prisma.ProcessingAttemptGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProcessingAttemptGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProcessingAttemptCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProcessingAttemptCountAggregateOutputType> | number
        }
      }
    }
    ProcessingCheckpoint: {
      payload: Prisma.$ProcessingCheckpointPayload<ExtArgs>
      fields: Prisma.ProcessingCheckpointFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProcessingCheckpointFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingCheckpointPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProcessingCheckpointFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingCheckpointPayload>
        }
        findFirst: {
          args: Prisma.ProcessingCheckpointFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingCheckpointPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProcessingCheckpointFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingCheckpointPayload>
        }
        findMany: {
          args: Prisma.ProcessingCheckpointFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingCheckpointPayload>[]
        }
        create: {
          args: Prisma.ProcessingCheckpointCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingCheckpointPayload>
        }
        createMany: {
          args: Prisma.ProcessingCheckpointCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProcessingCheckpointCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingCheckpointPayload>[]
        }
        delete: {
          args: Prisma.ProcessingCheckpointDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingCheckpointPayload>
        }
        update: {
          args: Prisma.ProcessingCheckpointUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingCheckpointPayload>
        }
        deleteMany: {
          args: Prisma.ProcessingCheckpointDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProcessingCheckpointUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProcessingCheckpointUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingCheckpointPayload>[]
        }
        upsert: {
          args: Prisma.ProcessingCheckpointUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessingCheckpointPayload>
        }
        aggregate: {
          args: Prisma.ProcessingCheckpointAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProcessingCheckpoint>
        }
        groupBy: {
          args: Prisma.ProcessingCheckpointGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProcessingCheckpointGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProcessingCheckpointCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProcessingCheckpointCountAggregateOutputType> | number
        }
      }
    }
    SplitPlan: {
      payload: Prisma.$SplitPlanPayload<ExtArgs>
      fields: Prisma.SplitPlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SplitPlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SplitPlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SplitPlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SplitPlanPayload>
        }
        findFirst: {
          args: Prisma.SplitPlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SplitPlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SplitPlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SplitPlanPayload>
        }
        findMany: {
          args: Prisma.SplitPlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SplitPlanPayload>[]
        }
        create: {
          args: Prisma.SplitPlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SplitPlanPayload>
        }
        createMany: {
          args: Prisma.SplitPlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SplitPlanCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SplitPlanPayload>[]
        }
        delete: {
          args: Prisma.SplitPlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SplitPlanPayload>
        }
        update: {
          args: Prisma.SplitPlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SplitPlanPayload>
        }
        deleteMany: {
          args: Prisma.SplitPlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SplitPlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SplitPlanUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SplitPlanPayload>[]
        }
        upsert: {
          args: Prisma.SplitPlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SplitPlanPayload>
        }
        aggregate: {
          args: Prisma.SplitPlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSplitPlan>
        }
        groupBy: {
          args: Prisma.SplitPlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SplitPlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.SplitPlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SplitPlanCountAggregateOutputType> | number
        }
      }
    }
    DocumentStateEvent: {
      payload: Prisma.$DocumentStateEventPayload<ExtArgs>
      fields: Prisma.DocumentStateEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentStateEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentStateEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentStateEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentStateEventPayload>
        }
        findFirst: {
          args: Prisma.DocumentStateEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentStateEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentStateEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentStateEventPayload>
        }
        findMany: {
          args: Prisma.DocumentStateEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentStateEventPayload>[]
        }
        create: {
          args: Prisma.DocumentStateEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentStateEventPayload>
        }
        createMany: {
          args: Prisma.DocumentStateEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentStateEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentStateEventPayload>[]
        }
        delete: {
          args: Prisma.DocumentStateEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentStateEventPayload>
        }
        update: {
          args: Prisma.DocumentStateEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentStateEventPayload>
        }
        deleteMany: {
          args: Prisma.DocumentStateEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentStateEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentStateEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentStateEventPayload>[]
        }
        upsert: {
          args: Prisma.DocumentStateEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentStateEventPayload>
        }
        aggregate: {
          args: Prisma.DocumentStateEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentStateEvent>
        }
        groupBy: {
          args: Prisma.DocumentStateEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentStateEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentStateEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentStateEventCountAggregateOutputType> | number
        }
      }
    }
    DocumentDerivedFile: {
      payload: Prisma.$DocumentDerivedFilePayload<ExtArgs>
      fields: Prisma.DocumentDerivedFileFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentDerivedFileFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDerivedFilePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentDerivedFileFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDerivedFilePayload>
        }
        findFirst: {
          args: Prisma.DocumentDerivedFileFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDerivedFilePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentDerivedFileFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDerivedFilePayload>
        }
        findMany: {
          args: Prisma.DocumentDerivedFileFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDerivedFilePayload>[]
        }
        create: {
          args: Prisma.DocumentDerivedFileCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDerivedFilePayload>
        }
        createMany: {
          args: Prisma.DocumentDerivedFileCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentDerivedFileCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDerivedFilePayload>[]
        }
        delete: {
          args: Prisma.DocumentDerivedFileDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDerivedFilePayload>
        }
        update: {
          args: Prisma.DocumentDerivedFileUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDerivedFilePayload>
        }
        deleteMany: {
          args: Prisma.DocumentDerivedFileDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentDerivedFileUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentDerivedFileUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDerivedFilePayload>[]
        }
        upsert: {
          args: Prisma.DocumentDerivedFileUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDerivedFilePayload>
        }
        aggregate: {
          args: Prisma.DocumentDerivedFileAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentDerivedFile>
        }
        groupBy: {
          args: Prisma.DocumentDerivedFileGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentDerivedFileGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentDerivedFileCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentDerivedFileCountAggregateOutputType> | number
        }
      }
    }
    IdempotencyRecord: {
      payload: Prisma.$IdempotencyRecordPayload<ExtArgs>
      fields: Prisma.IdempotencyRecordFieldRefs
      operations: {
        findUnique: {
          args: Prisma.IdempotencyRecordFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IdempotencyRecordPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.IdempotencyRecordFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IdempotencyRecordPayload>
        }
        findFirst: {
          args: Prisma.IdempotencyRecordFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IdempotencyRecordPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.IdempotencyRecordFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IdempotencyRecordPayload>
        }
        findMany: {
          args: Prisma.IdempotencyRecordFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IdempotencyRecordPayload>[]
        }
        create: {
          args: Prisma.IdempotencyRecordCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IdempotencyRecordPayload>
        }
        createMany: {
          args: Prisma.IdempotencyRecordCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.IdempotencyRecordCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IdempotencyRecordPayload>[]
        }
        delete: {
          args: Prisma.IdempotencyRecordDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IdempotencyRecordPayload>
        }
        update: {
          args: Prisma.IdempotencyRecordUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IdempotencyRecordPayload>
        }
        deleteMany: {
          args: Prisma.IdempotencyRecordDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.IdempotencyRecordUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.IdempotencyRecordUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IdempotencyRecordPayload>[]
        }
        upsert: {
          args: Prisma.IdempotencyRecordUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IdempotencyRecordPayload>
        }
        aggregate: {
          args: Prisma.IdempotencyRecordAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIdempotencyRecord>
        }
        groupBy: {
          args: Prisma.IdempotencyRecordGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IdempotencyRecordGroupByOutputType>[]
        }
        count: {
          args: Prisma.IdempotencyRecordCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IdempotencyRecordCountAggregateOutputType> | number
        }
      }
    }
    WebhookSubscription: {
      payload: Prisma.$WebhookSubscriptionPayload<ExtArgs>
      fields: Prisma.WebhookSubscriptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WebhookSubscriptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WebhookSubscriptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
        }
        findFirst: {
          args: Prisma.WebhookSubscriptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WebhookSubscriptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
        }
        findMany: {
          args: Prisma.WebhookSubscriptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>[]
        }
        create: {
          args: Prisma.WebhookSubscriptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
        }
        createMany: {
          args: Prisma.WebhookSubscriptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WebhookSubscriptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>[]
        }
        delete: {
          args: Prisma.WebhookSubscriptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
        }
        update: {
          args: Prisma.WebhookSubscriptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
        }
        deleteMany: {
          args: Prisma.WebhookSubscriptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WebhookSubscriptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WebhookSubscriptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>[]
        }
        upsert: {
          args: Prisma.WebhookSubscriptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
        }
        aggregate: {
          args: Prisma.WebhookSubscriptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWebhookSubscription>
        }
        groupBy: {
          args: Prisma.WebhookSubscriptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookSubscriptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.WebhookSubscriptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookSubscriptionCountAggregateOutputType> | number
        }
      }
    }
    ExchangeRate: {
      payload: Prisma.$ExchangeRatePayload<ExtArgs>
      fields: Prisma.ExchangeRateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExchangeRateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExchangeRateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        findFirst: {
          args: Prisma.ExchangeRateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExchangeRateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        findMany: {
          args: Prisma.ExchangeRateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
        }
        create: {
          args: Prisma.ExchangeRateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        createMany: {
          args: Prisma.ExchangeRateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExchangeRateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
        }
        delete: {
          args: Prisma.ExchangeRateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        update: {
          args: Prisma.ExchangeRateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        deleteMany: {
          args: Prisma.ExchangeRateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExchangeRateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExchangeRateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
        }
        upsert: {
          args: Prisma.ExchangeRateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        aggregate: {
          args: Prisma.ExchangeRateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExchangeRate>
        }
        groupBy: {
          args: Prisma.ExchangeRateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExchangeRateGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExchangeRateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExchangeRateCountAggregateOutputType> | number
        }
      }
    }
    BankAccount: {
      payload: Prisma.$BankAccountPayload<ExtArgs>
      fields: Prisma.BankAccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>
        }
        findFirst: {
          args: Prisma.BankAccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>
        }
        findMany: {
          args: Prisma.BankAccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
        }
        create: {
          args: Prisma.BankAccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>
        }
        createMany: {
          args: Prisma.BankAccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BankAccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
        }
        delete: {
          args: Prisma.BankAccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>
        }
        update: {
          args: Prisma.BankAccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>
        }
        deleteMany: {
          args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BankAccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
        }
        upsert: {
          args: Prisma.BankAccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankAccountPayload>
        }
        aggregate: {
          args: Prisma.BankAccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBankAccount>
        }
        groupBy: {
          args: Prisma.BankAccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BankAccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.BankAccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BankAccountCountAggregateOutputType> | number
        }
      }
    }
    BankTransaction: {
      payload: Prisma.$BankTransactionPayload<ExtArgs>
      fields: Prisma.BankTransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BankTransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BankTransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>
        }
        findFirst: {
          args: Prisma.BankTransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BankTransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>
        }
        findMany: {
          args: Prisma.BankTransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
        }
        create: {
          args: Prisma.BankTransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>
        }
        createMany: {
          args: Prisma.BankTransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BankTransactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
        }
        delete: {
          args: Prisma.BankTransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>
        }
        update: {
          args: Prisma.BankTransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>
        }
        deleteMany: {
          args: Prisma.BankTransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BankTransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BankTransactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
        }
        upsert: {
          args: Prisma.BankTransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>
        }
        aggregate: {
          args: Prisma.BankTransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBankTransaction>
        }
        groupBy: {
          args: Prisma.BankTransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BankTransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.BankTransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BankTransactionCountAggregateOutputType> | number
        }
      }
    }
    MatchGroup: {
      payload: Prisma.$MatchGroupPayload<ExtArgs>
      fields: Prisma.MatchGroupFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MatchGroupFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MatchGroupFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupPayload>
        }
        findFirst: {
          args: Prisma.MatchGroupFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MatchGroupFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupPayload>
        }
        findMany: {
          args: Prisma.MatchGroupFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupPayload>[]
        }
        create: {
          args: Prisma.MatchGroupCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupPayload>
        }
        createMany: {
          args: Prisma.MatchGroupCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MatchGroupCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupPayload>[]
        }
        delete: {
          args: Prisma.MatchGroupDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupPayload>
        }
        update: {
          args: Prisma.MatchGroupUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupPayload>
        }
        deleteMany: {
          args: Prisma.MatchGroupDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MatchGroupUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MatchGroupUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupPayload>[]
        }
        upsert: {
          args: Prisma.MatchGroupUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupPayload>
        }
        aggregate: {
          args: Prisma.MatchGroupAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMatchGroup>
        }
        groupBy: {
          args: Prisma.MatchGroupGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MatchGroupGroupByOutputType>[]
        }
        count: {
          args: Prisma.MatchGroupCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MatchGroupCountAggregateOutputType> | number
        }
      }
    }
    MatchGroupItem: {
      payload: Prisma.$MatchGroupItemPayload<ExtArgs>
      fields: Prisma.MatchGroupItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MatchGroupItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MatchGroupItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupItemPayload>
        }
        findFirst: {
          args: Prisma.MatchGroupItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MatchGroupItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupItemPayload>
        }
        findMany: {
          args: Prisma.MatchGroupItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupItemPayload>[]
        }
        create: {
          args: Prisma.MatchGroupItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupItemPayload>
        }
        createMany: {
          args: Prisma.MatchGroupItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MatchGroupItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupItemPayload>[]
        }
        delete: {
          args: Prisma.MatchGroupItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupItemPayload>
        }
        update: {
          args: Prisma.MatchGroupItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupItemPayload>
        }
        deleteMany: {
          args: Prisma.MatchGroupItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MatchGroupItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MatchGroupItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupItemPayload>[]
        }
        upsert: {
          args: Prisma.MatchGroupItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchGroupItemPayload>
        }
        aggregate: {
          args: Prisma.MatchGroupItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMatchGroupItem>
        }
        groupBy: {
          args: Prisma.MatchGroupItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MatchGroupItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.MatchGroupItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MatchGroupItemCountAggregateOutputType> | number
        }
      }
    }
    ReconciliationPeriod: {
      payload: Prisma.$ReconciliationPeriodPayload<ExtArgs>
      fields: Prisma.ReconciliationPeriodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReconciliationPeriodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReconciliationPeriodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReconciliationPeriodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReconciliationPeriodPayload>
        }
        findFirst: {
          args: Prisma.ReconciliationPeriodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReconciliationPeriodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReconciliationPeriodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReconciliationPeriodPayload>
        }
        findMany: {
          args: Prisma.ReconciliationPeriodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReconciliationPeriodPayload>[]
        }
        create: {
          args: Prisma.ReconciliationPeriodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReconciliationPeriodPayload>
        }
        createMany: {
          args: Prisma.ReconciliationPeriodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReconciliationPeriodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReconciliationPeriodPayload>[]
        }
        delete: {
          args: Prisma.ReconciliationPeriodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReconciliationPeriodPayload>
        }
        update: {
          args: Prisma.ReconciliationPeriodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReconciliationPeriodPayload>
        }
        deleteMany: {
          args: Prisma.ReconciliationPeriodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReconciliationPeriodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReconciliationPeriodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReconciliationPeriodPayload>[]
        }
        upsert: {
          args: Prisma.ReconciliationPeriodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReconciliationPeriodPayload>
        }
        aggregate: {
          args: Prisma.ReconciliationPeriodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReconciliationPeriod>
        }
        groupBy: {
          args: Prisma.ReconciliationPeriodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReconciliationPeriodGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReconciliationPeriodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReconciliationPeriodCountAggregateOutputType> | number
        }
      }
    }
    ClientPortalUser: {
      payload: Prisma.$ClientPortalUserPayload<ExtArgs>
      fields: Prisma.ClientPortalUserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ClientPortalUserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPortalUserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ClientPortalUserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPortalUserPayload>
        }
        findFirst: {
          args: Prisma.ClientPortalUserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPortalUserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ClientPortalUserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPortalUserPayload>
        }
        findMany: {
          args: Prisma.ClientPortalUserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPortalUserPayload>[]
        }
        create: {
          args: Prisma.ClientPortalUserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPortalUserPayload>
        }
        createMany: {
          args: Prisma.ClientPortalUserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ClientPortalUserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPortalUserPayload>[]
        }
        delete: {
          args: Prisma.ClientPortalUserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPortalUserPayload>
        }
        update: {
          args: Prisma.ClientPortalUserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPortalUserPayload>
        }
        deleteMany: {
          args: Prisma.ClientPortalUserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ClientPortalUserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ClientPortalUserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPortalUserPayload>[]
        }
        upsert: {
          args: Prisma.ClientPortalUserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPortalUserPayload>
        }
        aggregate: {
          args: Prisma.ClientPortalUserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateClientPortalUser>
        }
        groupBy: {
          args: Prisma.ClientPortalUserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ClientPortalUserGroupByOutputType>[]
        }
        count: {
          args: Prisma.ClientPortalUserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ClientPortalUserCountAggregateOutputType> | number
        }
      }
    }
    ClientRequest: {
      payload: Prisma.$ClientRequestPayload<ExtArgs>
      fields: Prisma.ClientRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ClientRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ClientRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientRequestPayload>
        }
        findFirst: {
          args: Prisma.ClientRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ClientRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientRequestPayload>
        }
        findMany: {
          args: Prisma.ClientRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientRequestPayload>[]
        }
        create: {
          args: Prisma.ClientRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientRequestPayload>
        }
        createMany: {
          args: Prisma.ClientRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ClientRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientRequestPayload>[]
        }
        delete: {
          args: Prisma.ClientRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientRequestPayload>
        }
        update: {
          args: Prisma.ClientRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientRequestPayload>
        }
        deleteMany: {
          args: Prisma.ClientRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ClientRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ClientRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientRequestPayload>[]
        }
        upsert: {
          args: Prisma.ClientRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientRequestPayload>
        }
        aggregate: {
          args: Prisma.ClientRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateClientRequest>
        }
        groupBy: {
          args: Prisma.ClientRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ClientRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.ClientRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ClientRequestCountAggregateOutputType> | number
        }
      }
    }
    Communication: {
      payload: Prisma.$CommunicationPayload<ExtArgs>
      fields: Prisma.CommunicationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommunicationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommunicationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>
        }
        findFirst: {
          args: Prisma.CommunicationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommunicationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>
        }
        findMany: {
          args: Prisma.CommunicationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
        }
        create: {
          args: Prisma.CommunicationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>
        }
        createMany: {
          args: Prisma.CommunicationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommunicationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
        }
        delete: {
          args: Prisma.CommunicationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>
        }
        update: {
          args: Prisma.CommunicationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>
        }
        deleteMany: {
          args: Prisma.CommunicationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommunicationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommunicationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
        }
        upsert: {
          args: Prisma.CommunicationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>
        }
        aggregate: {
          args: Prisma.CommunicationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommunication>
        }
        groupBy: {
          args: Prisma.CommunicationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommunicationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationCountAggregateOutputType> | number
        }
      }
    }
    AccountingIntegration: {
      payload: Prisma.$AccountingIntegrationPayload<ExtArgs>
      fields: Prisma.AccountingIntegrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AccountingIntegrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingIntegrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AccountingIntegrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingIntegrationPayload>
        }
        findFirst: {
          args: Prisma.AccountingIntegrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingIntegrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AccountingIntegrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingIntegrationPayload>
        }
        findMany: {
          args: Prisma.AccountingIntegrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingIntegrationPayload>[]
        }
        create: {
          args: Prisma.AccountingIntegrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingIntegrationPayload>
        }
        createMany: {
          args: Prisma.AccountingIntegrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AccountingIntegrationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingIntegrationPayload>[]
        }
        delete: {
          args: Prisma.AccountingIntegrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingIntegrationPayload>
        }
        update: {
          args: Prisma.AccountingIntegrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingIntegrationPayload>
        }
        deleteMany: {
          args: Prisma.AccountingIntegrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AccountingIntegrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AccountingIntegrationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingIntegrationPayload>[]
        }
        upsert: {
          args: Prisma.AccountingIntegrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingIntegrationPayload>
        }
        aggregate: {
          args: Prisma.AccountingIntegrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccountingIntegration>
        }
        groupBy: {
          args: Prisma.AccountingIntegrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountingIntegrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.AccountingIntegrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountingIntegrationCountAggregateOutputType> | number
        }
      }
    }
    ExternalPosting: {
      payload: Prisma.$ExternalPostingPayload<ExtArgs>
      fields: Prisma.ExternalPostingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExternalPostingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExternalPostingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExternalPostingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExternalPostingPayload>
        }
        findFirst: {
          args: Prisma.ExternalPostingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExternalPostingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExternalPostingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExternalPostingPayload>
        }
        findMany: {
          args: Prisma.ExternalPostingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExternalPostingPayload>[]
        }
        create: {
          args: Prisma.ExternalPostingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExternalPostingPayload>
        }
        createMany: {
          args: Prisma.ExternalPostingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExternalPostingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExternalPostingPayload>[]
        }
        delete: {
          args: Prisma.ExternalPostingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExternalPostingPayload>
        }
        update: {
          args: Prisma.ExternalPostingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExternalPostingPayload>
        }
        deleteMany: {
          args: Prisma.ExternalPostingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExternalPostingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExternalPostingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExternalPostingPayload>[]
        }
        upsert: {
          args: Prisma.ExternalPostingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExternalPostingPayload>
        }
        aggregate: {
          args: Prisma.ExternalPostingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExternalPosting>
        }
        groupBy: {
          args: Prisma.ExternalPostingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExternalPostingGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExternalPostingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExternalPostingCountAggregateOutputType> | number
        }
      }
    }
    FieldMapping: {
      payload: Prisma.$FieldMappingPayload<ExtArgs>
      fields: Prisma.FieldMappingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FieldMappingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldMappingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FieldMappingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldMappingPayload>
        }
        findFirst: {
          args: Prisma.FieldMappingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldMappingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FieldMappingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldMappingPayload>
        }
        findMany: {
          args: Prisma.FieldMappingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldMappingPayload>[]
        }
        create: {
          args: Prisma.FieldMappingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldMappingPayload>
        }
        createMany: {
          args: Prisma.FieldMappingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FieldMappingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldMappingPayload>[]
        }
        delete: {
          args: Prisma.FieldMappingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldMappingPayload>
        }
        update: {
          args: Prisma.FieldMappingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldMappingPayload>
        }
        deleteMany: {
          args: Prisma.FieldMappingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FieldMappingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FieldMappingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldMappingPayload>[]
        }
        upsert: {
          args: Prisma.FieldMappingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldMappingPayload>
        }
        aggregate: {
          args: Prisma.FieldMappingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFieldMapping>
        }
        groupBy: {
          args: Prisma.FieldMappingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FieldMappingGroupByOutputType>[]
        }
        count: {
          args: Prisma.FieldMappingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FieldMappingCountAggregateOutputType> | number
        }
      }
    }
    TenantBackup: {
      payload: Prisma.$TenantBackupPayload<ExtArgs>
      fields: Prisma.TenantBackupFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantBackupFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantBackupPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantBackupFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantBackupPayload>
        }
        findFirst: {
          args: Prisma.TenantBackupFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantBackupPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantBackupFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantBackupPayload>
        }
        findMany: {
          args: Prisma.TenantBackupFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantBackupPayload>[]
        }
        create: {
          args: Prisma.TenantBackupCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantBackupPayload>
        }
        createMany: {
          args: Prisma.TenantBackupCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantBackupCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantBackupPayload>[]
        }
        delete: {
          args: Prisma.TenantBackupDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantBackupPayload>
        }
        update: {
          args: Prisma.TenantBackupUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantBackupPayload>
        }
        deleteMany: {
          args: Prisma.TenantBackupDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantBackupUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantBackupUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantBackupPayload>[]
        }
        upsert: {
          args: Prisma.TenantBackupUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantBackupPayload>
        }
        aggregate: {
          args: Prisma.TenantBackupAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantBackup>
        }
        groupBy: {
          args: Prisma.TenantBackupGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantBackupGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantBackupCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantBackupCountAggregateOutputType> | number
        }
      }
    }
    BackupSchedule: {
      payload: Prisma.$BackupSchedulePayload<ExtArgs>
      fields: Prisma.BackupScheduleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BackupScheduleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BackupSchedulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BackupScheduleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BackupSchedulePayload>
        }
        findFirst: {
          args: Prisma.BackupScheduleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BackupSchedulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BackupScheduleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BackupSchedulePayload>
        }
        findMany: {
          args: Prisma.BackupScheduleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BackupSchedulePayload>[]
        }
        create: {
          args: Prisma.BackupScheduleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BackupSchedulePayload>
        }
        createMany: {
          args: Prisma.BackupScheduleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BackupScheduleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BackupSchedulePayload>[]
        }
        delete: {
          args: Prisma.BackupScheduleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BackupSchedulePayload>
        }
        update: {
          args: Prisma.BackupScheduleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BackupSchedulePayload>
        }
        deleteMany: {
          args: Prisma.BackupScheduleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BackupScheduleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BackupScheduleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BackupSchedulePayload>[]
        }
        upsert: {
          args: Prisma.BackupScheduleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BackupSchedulePayload>
        }
        aggregate: {
          args: Prisma.BackupScheduleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBackupSchedule>
        }
        groupBy: {
          args: Prisma.BackupScheduleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BackupScheduleGroupByOutputType>[]
        }
        count: {
          args: Prisma.BackupScheduleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BackupScheduleCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const TenantScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  status: 'status',
  contactEmail: 'contactEmail',
  contactPhone: 'contactPhone',
  settings: 'settings',
  maxUsers: 'maxUsers',
  maxCompanies: 'maxCompanies',
  maxStorageMb: 'maxStorageMb',
  logoUrl: 'logoUrl',
  primaryColor: 'primaryColor',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  deletedReason: 'deletedReason',
  activatedAt: 'activatedAt',
  suspendedAt: 'suspendedAt',
  suspendReason: 'suspendReason'
} as const

export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


export const RoleScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  isSystem: 'isSystem',
  systemRoleType: 'systemRoleType',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


export const PermissionScalarFieldEnum = {
  id: 'id',
  resource: 'resource',
  action: 'action',
  description: 'description'
} as const

export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


export const RolePermissionScalarFieldEnum = {
  id: 'id',
  roleId: 'roleId',
  permissionId: 'permissionId',
  createdAt: 'createdAt'
} as const

export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


export const UserRoleAssignmentScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  roleId: 'roleId',
  companyId: 'companyId',
  createdAt: 'createdAt'
} as const

export type UserRoleAssignmentScalarFieldEnum = (typeof UserRoleAssignmentScalarFieldEnum)[keyof typeof UserRoleAssignmentScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  passwordHash: 'passwordHash',
  firstName: 'firstName',
  lastName: 'lastName',
  isActive: 'isActive',
  lastLoginAt: 'lastLoginAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  mustChangePassword: 'mustChangePassword',
  passwordResetToken: 'passwordResetToken',
  passwordResetExpires: 'passwordResetExpires',
  passwordChangedAt: 'passwordChangedAt',
  tenantId: 'tenantId'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const UserCompanyAssignmentScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  companyId: 'companyId',
  isPrimary: 'isPrimary',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserCompanyAssignmentScalarFieldEnum = (typeof UserCompanyAssignmentScalarFieldEnum)[keyof typeof UserCompanyAssignmentScalarFieldEnum]


export const CompanyScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  uen: 'uen',
  name: 'name',
  formerName: 'formerName',
  dateOfNameChange: 'dateOfNameChange',
  entityType: 'entityType',
  status: 'status',
  statusDate: 'statusDate',
  incorporationDate: 'incorporationDate',
  registrationDate: 'registrationDate',
  dateOfAddress: 'dateOfAddress',
  primarySsicCode: 'primarySsicCode',
  primarySsicDescription: 'primarySsicDescription',
  secondarySsicCode: 'secondarySsicCode',
  secondarySsicDescription: 'secondarySsicDescription',
  financialYearEndDay: 'financialYearEndDay',
  financialYearEndMonth: 'financialYearEndMonth',
  fyeAsAtLastAr: 'fyeAsAtLastAr',
  homeCurrency: 'homeCurrency',
  lastAgmDate: 'lastAgmDate',
  lastArFiledDate: 'lastArFiledDate',
  nextAgmDueDate: 'nextAgmDueDate',
  nextArDueDate: 'nextArDueDate',
  accountsDueDate: 'accountsDueDate',
  paidUpCapitalCurrency: 'paidUpCapitalCurrency',
  paidUpCapitalAmount: 'paidUpCapitalAmount',
  issuedCapitalCurrency: 'issuedCapitalCurrency',
  issuedCapitalAmount: 'issuedCapitalAmount',
  hasCharges: 'hasCharges',
  isGstRegistered: 'isGstRegistered',
  gstRegistrationNumber: 'gstRegistrationNumber',
  gstRegistrationDate: 'gstRegistrationDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  deletedReason: 'deletedReason'
} as const

export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


export const CompanyFormerNameScalarFieldEnum = {
  id: 'id',
  companyId: 'companyId',
  formerName: 'formerName',
  effectiveFrom: 'effectiveFrom',
  effectiveTo: 'effectiveTo',
  sourceDocumentId: 'sourceDocumentId',
  createdAt: 'createdAt'
} as const

export type CompanyFormerNameScalarFieldEnum = (typeof CompanyFormerNameScalarFieldEnum)[keyof typeof CompanyFormerNameScalarFieldEnum]


export const CompanyAddressScalarFieldEnum = {
  id: 'id',
  companyId: 'companyId',
  addressType: 'addressType',
  block: 'block',
  streetName: 'streetName',
  level: 'level',
  unit: 'unit',
  buildingName: 'buildingName',
  postalCode: 'postalCode',
  country: 'country',
  fullAddress: 'fullAddress',
  effectiveFrom: 'effectiveFrom',
  effectiveTo: 'effectiveTo',
  isCurrent: 'isCurrent',
  sourceDocumentId: 'sourceDocumentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyAddressScalarFieldEnum = (typeof CompanyAddressScalarFieldEnum)[keyof typeof CompanyAddressScalarFieldEnum]


export const ContactScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  contactType: 'contactType',
  firstName: 'firstName',
  lastName: 'lastName',
  fullName: 'fullName',
  identificationType: 'identificationType',
  identificationNumber: 'identificationNumber',
  nationality: 'nationality',
  dateOfBirth: 'dateOfBirth',
  corporateName: 'corporateName',
  corporateUen: 'corporateUen',
  email: 'email',
  phone: 'phone',
  fullAddress: 'fullAddress',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


export const CompanyContactScalarFieldEnum = {
  id: 'id',
  companyId: 'companyId',
  contactId: 'contactId',
  relationship: 'relationship',
  isPrimary: 'isPrimary',
  createdAt: 'createdAt',
  deletedAt: 'deletedAt'
} as const

export type CompanyContactScalarFieldEnum = (typeof CompanyContactScalarFieldEnum)[keyof typeof CompanyContactScalarFieldEnum]


export const CompanyOfficerScalarFieldEnum = {
  id: 'id',
  companyId: 'companyId',
  contactId: 'contactId',
  role: 'role',
  name: 'name',
  identificationType: 'identificationType',
  identificationNumber: 'identificationNumber',
  nationality: 'nationality',
  address: 'address',
  appointmentDate: 'appointmentDate',
  cessationDate: 'cessationDate',
  isCurrent: 'isCurrent',
  sourceDocumentId: 'sourceDocumentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyOfficerScalarFieldEnum = (typeof CompanyOfficerScalarFieldEnum)[keyof typeof CompanyOfficerScalarFieldEnum]


export const ShareCapitalScalarFieldEnum = {
  id: 'id',
  companyId: 'companyId',
  shareClass: 'shareClass',
  currency: 'currency',
  numberOfShares: 'numberOfShares',
  parValue: 'parValue',
  totalValue: 'totalValue',
  isPaidUp: 'isPaidUp',
  isTreasury: 'isTreasury',
  effectiveDate: 'effectiveDate',
  sourceDocumentId: 'sourceDocumentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ShareCapitalScalarFieldEnum = (typeof ShareCapitalScalarFieldEnum)[keyof typeof ShareCapitalScalarFieldEnum]


export const CompanyShareholderScalarFieldEnum = {
  id: 'id',
  companyId: 'companyId',
  contactId: 'contactId',
  name: 'name',
  shareholderType: 'shareholderType',
  identificationType: 'identificationType',
  identificationNumber: 'identificationNumber',
  nationality: 'nationality',
  placeOfOrigin: 'placeOfOrigin',
  address: 'address',
  shareClass: 'shareClass',
  numberOfShares: 'numberOfShares',
  percentageHeld: 'percentageHeld',
  currency: 'currency',
  allotmentDate: 'allotmentDate',
  transferDate: 'transferDate',
  isCurrent: 'isCurrent',
  sourceDocumentId: 'sourceDocumentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyShareholderScalarFieldEnum = (typeof CompanyShareholderScalarFieldEnum)[keyof typeof CompanyShareholderScalarFieldEnum]


export const CompanyChargeScalarFieldEnum = {
  id: 'id',
  companyId: 'companyId',
  chargeHolderId: 'chargeHolderId',
  chargeNumber: 'chargeNumber',
  chargeType: 'chargeType',
  description: 'description',
  chargeHolderName: 'chargeHolderName',
  amountSecured: 'amountSecured',
  amountSecuredText: 'amountSecuredText',
  currency: 'currency',
  registrationDate: 'registrationDate',
  dischargeDate: 'dischargeDate',
  isFullyDischarged: 'isFullyDischarged',
  sourceDocumentId: 'sourceDocumentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyChargeScalarFieldEnum = (typeof CompanyChargeScalarFieldEnum)[keyof typeof CompanyChargeScalarFieldEnum]


export const DocumentScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  companyId: 'companyId',
  uploadedById: 'uploadedById',
  documentType: 'documentType',
  fileName: 'fileName',
  originalFileName: 'originalFileName',
  storageKey: 'storageKey',
  fileSize: 'fileSize',
  mimeType: 'mimeType',
  extractedAt: 'extractedAt',
  extractionStatus: 'extractionStatus',
  extractionError: 'extractionError',
  extractedData: 'extractedData',
  version: 'version',
  isLatest: 'isLatest',
  previousVersionId: 'previousVersionId',
  deletedAt: 'deletedAt',
  deletedReason: 'deletedReason',
  deletedById: 'deletedById',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


export const AuditLogScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  userId: 'userId',
  companyId: 'companyId',
  action: 'action',
  entityType: 'entityType',
  entityId: 'entityId',
  changeSource: 'changeSource',
  changes: 'changes',
  reason: 'reason',
  summary: 'summary',
  entityName: 'entityName',
  metadata: 'metadata',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  requestId: 'requestId',
  sessionId: 'sessionId',
  createdAt: 'createdAt'
} as const

export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


export const ConnectorScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  type: 'type',
  provider: 'provider',
  credentials: 'credentials',
  settings: 'settings',
  isEnabled: 'isEnabled',
  isDefault: 'isDefault',
  callCount: 'callCount',
  lastUsedAt: 'lastUsedAt',
  lastTestedAt: 'lastTestedAt',
  lastTestResult: 'lastTestResult',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type ConnectorScalarFieldEnum = (typeof ConnectorScalarFieldEnum)[keyof typeof ConnectorScalarFieldEnum]


export const TenantConnectorAccessScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  connectorId: 'connectorId',
  isEnabled: 'isEnabled',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantConnectorAccessScalarFieldEnum = (typeof TenantConnectorAccessScalarFieldEnum)[keyof typeof TenantConnectorAccessScalarFieldEnum]


export const ConnectorUsageLogScalarFieldEnum = {
  id: 'id',
  connectorId: 'connectorId',
  tenantId: 'tenantId',
  userId: 'userId',
  model: 'model',
  provider: 'provider',
  inputTokens: 'inputTokens',
  outputTokens: 'outputTokens',
  totalTokens: 'totalTokens',
  costCents: 'costCents',
  latencyMs: 'latencyMs',
  operation: 'operation',
  success: 'success',
  errorMessage: 'errorMessage',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type ConnectorUsageLogScalarFieldEnum = (typeof ConnectorUsageLogScalarFieldEnum)[keyof typeof ConnectorUsageLogScalarFieldEnum]


export const NoteTabScalarFieldEnum = {
  id: 'id',
  title: 'title',
  content: 'content',
  order: 'order',
  companyId: 'companyId',
  contactId: 'contactId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NoteTabScalarFieldEnum = (typeof NoteTabScalarFieldEnum)[keyof typeof NoteTabScalarFieldEnum]


export const DocumentTemplateScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  category: 'category',
  content: 'content',
  contentJson: 'contentJson',
  placeholders: 'placeholders',
  isActive: 'isActive',
  defaultShareExpiryHours: 'defaultShareExpiryHours',
  version: 'version',
  createdById: 'createdById',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type DocumentTemplateScalarFieldEnum = (typeof DocumentTemplateScalarFieldEnum)[keyof typeof DocumentTemplateScalarFieldEnum]


export const GeneratedDocumentScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  templateId: 'templateId',
  templateVersion: 'templateVersion',
  companyId: 'companyId',
  title: 'title',
  content: 'content',
  contentJson: 'contentJson',
  status: 'status',
  finalizedAt: 'finalizedAt',
  finalizedById: 'finalizedById',
  unfinalizedAt: 'unfinalizedAt',
  useLetterhead: 'useLetterhead',
  shareExpiryHours: 'shareExpiryHours',
  placeholderData: 'placeholderData',
  metadata: 'metadata',
  createdById: 'createdById',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type GeneratedDocumentScalarFieldEnum = (typeof GeneratedDocumentScalarFieldEnum)[keyof typeof GeneratedDocumentScalarFieldEnum]


export const DocumentSectionScalarFieldEnum = {
  id: 'id',
  documentId: 'documentId',
  title: 'title',
  anchor: 'anchor',
  order: 'order',
  level: 'level',
  pageBreakBefore: 'pageBreakBefore',
  createdAt: 'createdAt'
} as const

export type DocumentSectionScalarFieldEnum = (typeof DocumentSectionScalarFieldEnum)[keyof typeof DocumentSectionScalarFieldEnum]


export const DocumentShareScalarFieldEnum = {
  id: 'id',
  documentId: 'documentId',
  shareToken: 'shareToken',
  expiresAt: 'expiresAt',
  passwordHash: 'passwordHash',
  isActive: 'isActive',
  viewCount: 'viewCount',
  lastViewedAt: 'lastViewedAt',
  allowedActions: 'allowedActions',
  allowComments: 'allowComments',
  commentRateLimit: 'commentRateLimit',
  notifyOnComment: 'notifyOnComment',
  notifyOnView: 'notifyOnView',
  createdById: 'createdById',
  createdAt: 'createdAt',
  revokedAt: 'revokedAt'
} as const

export type DocumentShareScalarFieldEnum = (typeof DocumentShareScalarFieldEnum)[keyof typeof DocumentShareScalarFieldEnum]


export const TenantLetterheadScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  headerHtml: 'headerHtml',
  footerHtml: 'footerHtml',
  headerImageUrl: 'headerImageUrl',
  footerImageUrl: 'footerImageUrl',
  logoUrl: 'logoUrl',
  pageMargins: 'pageMargins',
  isEnabled: 'isEnabled',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantLetterheadScalarFieldEnum = (typeof TenantLetterheadScalarFieldEnum)[keyof typeof TenantLetterheadScalarFieldEnum]


export const DocumentCommentScalarFieldEnum = {
  id: 'id',
  documentId: 'documentId',
  shareId: 'shareId',
  userId: 'userId',
  guestName: 'guestName',
  guestEmail: 'guestEmail',
  content: 'content',
  selectionStart: 'selectionStart',
  selectionEnd: 'selectionEnd',
  selectedText: 'selectedText',
  parentId: 'parentId',
  status: 'status',
  resolvedById: 'resolvedById',
  resolvedAt: 'resolvedAt',
  hiddenAt: 'hiddenAt',
  hiddenById: 'hiddenById',
  hiddenReason: 'hiddenReason',
  ipAddress: 'ipAddress',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type DocumentCommentScalarFieldEnum = (typeof DocumentCommentScalarFieldEnum)[keyof typeof DocumentCommentScalarFieldEnum]


export const DocumentDraftScalarFieldEnum = {
  id: 'id',
  documentId: 'documentId',
  userId: 'userId',
  content: 'content',
  contentJson: 'contentJson',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type DocumentDraftScalarFieldEnum = (typeof DocumentDraftScalarFieldEnum)[keyof typeof DocumentDraftScalarFieldEnum]


export const TemplatePartialScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  displayName: 'displayName',
  description: 'description',
  content: 'content',
  placeholders: 'placeholders',
  createdById: 'createdById',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type TemplatePartialScalarFieldEnum = (typeof TemplatePartialScalarFieldEnum)[keyof typeof TemplatePartialScalarFieldEnum]


export const AiConversationScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  userId: 'userId',
  contextType: 'contextType',
  contextId: 'contextId',
  messages: 'messages',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AiConversationScalarFieldEnum = (typeof AiConversationScalarFieldEnum)[keyof typeof AiConversationScalarFieldEnum]


export const ProcessingDocumentScalarFieldEnum = {
  id: 'id',
  documentId: 'documentId',
  isContainer: 'isContainer',
  parentProcessingDocId: 'parentProcessingDocId',
  pageFrom: 'pageFrom',
  pageTo: 'pageTo',
  pageCount: 'pageCount',
  fileHash: 'fileHash',
  perceptualHash: 'perceptualHash',
  isEncryptedPdf: 'isEncryptedPdf',
  isPasswordProtected: 'isPasswordProtected',
  contentTypeDetected: 'contentTypeDetected',
  pipelineStatus: 'pipelineStatus',
  processingPriority: 'processingPriority',
  slaDeadline: 'slaDeadline',
  lastError: 'lastError',
  errorCount: 'errorCount',
  firstErrorAt: 'firstErrorAt',
  canRetry: 'canRetry',
  nextRetryAt: 'nextRetryAt',
  deadLetterAt: 'deadLetterAt',
  duplicateStatus: 'duplicateStatus',
  duplicateOfId: 'duplicateOfId',
  duplicateScore: 'duplicateScore',
  duplicateReason: 'duplicateReason',
  rootDocumentId: 'rootDocumentId',
  version: 'version',
  deletedAt: 'deletedAt',
  deletedReason: 'deletedReason',
  currentRevisionId: 'currentRevisionId',
  lockVersion: 'lockVersion',
  lockedById: 'lockedById',
  lockedAt: 'lockedAt',
  lockExpiresAt: 'lockExpiresAt',
  uploadSource: 'uploadSource',
  legalHold: 'legalHold',
  retentionUntil: 'retentionUntil',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProcessingDocumentScalarFieldEnum = (typeof ProcessingDocumentScalarFieldEnum)[keyof typeof ProcessingDocumentScalarFieldEnum]


export const DocumentLinkScalarFieldEnum = {
  id: 'id',
  sourceDocumentId: 'sourceDocumentId',
  targetDocumentId: 'targetDocumentId',
  linkType: 'linkType',
  notes: 'notes',
  linkedById: 'linkedById',
  linkedAt: 'linkedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DocumentLinkScalarFieldEnum = (typeof DocumentLinkScalarFieldEnum)[keyof typeof DocumentLinkScalarFieldEnum]


export const DocumentPageScalarFieldEnum = {
  id: 'id',
  processingDocumentId: 'processingDocumentId',
  pageNumber: 'pageNumber',
  renderDpi: 'renderDpi',
  storageKey: 'storageKey',
  imageFingerprint: 'imageFingerprint',
  widthPx: 'widthPx',
  heightPx: 'heightPx',
  rotationDeg: 'rotationDeg',
  ocrProvider: 'ocrProvider',
  ocrJson: 'ocrJson',
  textAcquisitionDecision: 'textAcquisitionDecision',
  textAcquisitionSignals: 'textAcquisitionSignals',
  createdAt: 'createdAt'
} as const

export type DocumentPageScalarFieldEnum = (typeof DocumentPageScalarFieldEnum)[keyof typeof DocumentPageScalarFieldEnum]


export const DocumentExtractionScalarFieldEnum = {
  id: 'id',
  processingDocumentId: 'processingDocumentId',
  extractionType: 'extractionType',
  provider: 'provider',
  model: 'model',
  promptVersion: 'promptVersion',
  extractionSchemaVersion: 'extractionSchemaVersion',
  inputFingerprint: 'inputFingerprint',
  selectorVersion: 'selectorVersion',
  rawJson: 'rawJson',
  rawText: 'rawText',
  confidenceJson: 'confidenceJson',
  evidenceJson: 'evidenceJson',
  overallConfidence: 'overallConfidence',
  hasEmbeddedText: 'hasEmbeddedText',
  textAcquisitionJson: 'textAcquisitionJson',
  ocrProvider: 'ocrProvider',
  promptTokens: 'promptTokens',
  completionTokens: 'completionTokens',
  tokensUsed: 'tokensUsed',
  latencyMs: 'latencyMs',
  providerRequestId: 'providerRequestId',
  createdAt: 'createdAt'
} as const

export type DocumentExtractionScalarFieldEnum = (typeof DocumentExtractionScalarFieldEnum)[keyof typeof DocumentExtractionScalarFieldEnum]


export const DocumentRevisionScalarFieldEnum = {
  id: 'id',
  processingDocumentId: 'processingDocumentId',
  basedOnRevisionId: 'basedOnRevisionId',
  extractionId: 'extractionId',
  revisionNumber: 'revisionNumber',
  revisionType: 'revisionType',
  status: 'status',
  reason: 'reason',
  documentCategory: 'documentCategory',
  documentSubCategory: 'documentSubCategory',
  vendorName: 'vendorName',
  vendorId: 'vendorId',
  documentNumber: 'documentNumber',
  documentDate: 'documentDate',
  dueDate: 'dueDate',
  currency: 'currency',
  subtotal: 'subtotal',
  taxAmount: 'taxAmount',
  totalAmount: 'totalAmount',
  roundingMode: 'roundingMode',
  gstTreatment: 'gstTreatment',
  supplierGstNo: 'supplierGstNo',
  homeCurrency: 'homeCurrency',
  homeExchangeRateSource: 'homeExchangeRateSource',
  homeExchangeRate: 'homeExchangeRate',
  exchangeRateDate: 'exchangeRateDate',
  homeEquivalent: 'homeEquivalent',
  homeSubtotal: 'homeSubtotal',
  homeTaxAmount: 'homeTaxAmount',
  isHomeExchangeRateOverride: 'isHomeExchangeRateOverride',
  validationStatus: 'validationStatus',
  validationIssues: 'validationIssues',
  documentKey: 'documentKey',
  documentKeyVersion: 'documentKeyVersion',
  documentKeyConfidence: 'documentKeyConfidence',
  headerEvidenceJson: 'headerEvidenceJson',
  postingStatus: 'postingStatus',
  postedAt: 'postedAt',
  postingLock: 'postingLock',
  reconciliationStatus: 'reconciliationStatus',
  searchText: 'searchText',
  createdById: 'createdById',
  createdAt: 'createdAt',
  approvedById: 'approvedById',
  approvedAt: 'approvedAt',
  supersededAt: 'supersededAt'
} as const

export type DocumentRevisionScalarFieldEnum = (typeof DocumentRevisionScalarFieldEnum)[keyof typeof DocumentRevisionScalarFieldEnum]


export const DocumentRevisionLineItemScalarFieldEnum = {
  id: 'id',
  revisionId: 'revisionId',
  lineNo: 'lineNo',
  description: 'description',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  amount: 'amount',
  gstAmount: 'gstAmount',
  taxCode: 'taxCode',
  accountCode: 'accountCode',
  evidenceJson: 'evidenceJson',
  homeAmount: 'homeAmount',
  homeGstAmount: 'homeGstAmount',
  isHomeAmountOverride: 'isHomeAmountOverride',
  isHomeGstOverride: 'isHomeGstOverride'
} as const

export type DocumentRevisionLineItemScalarFieldEnum = (typeof DocumentRevisionLineItemScalarFieldEnum)[keyof typeof DocumentRevisionLineItemScalarFieldEnum]


export const VendorAliasScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  companyId: 'companyId',
  rawName: 'rawName',
  normalizedContactId: 'normalizedContactId',
  confidence: 'confidence',
  createdById: 'createdById',
  createdAt: 'createdAt',
  deletedAt: 'deletedAt'
} as const

export type VendorAliasScalarFieldEnum = (typeof VendorAliasScalarFieldEnum)[keyof typeof VendorAliasScalarFieldEnum]


export const DuplicateDecisionScalarFieldEnum = {
  id: 'id',
  processingDocumentId: 'processingDocumentId',
  suspectedOfId: 'suspectedOfId',
  decision: 'decision',
  reason: 'reason',
  decidedById: 'decidedById',
  decidedAt: 'decidedAt'
} as const

export type DuplicateDecisionScalarFieldEnum = (typeof DuplicateDecisionScalarFieldEnum)[keyof typeof DuplicateDecisionScalarFieldEnum]


export const ProcessingAttemptScalarFieldEnum = {
  id: 'id',
  processingDocumentId: 'processingDocumentId',
  attemptNumber: 'attemptNumber',
  step: 'step',
  status: 'status',
  startedAt: 'startedAt',
  completedAt: 'completedAt',
  errorCode: 'errorCode',
  errorMessage: 'errorMessage',
  errorDetails: 'errorDetails',
  providerLatencyMs: 'providerLatencyMs',
  providerRequestId: 'providerRequestId'
} as const

export type ProcessingAttemptScalarFieldEnum = (typeof ProcessingAttemptScalarFieldEnum)[keyof typeof ProcessingAttemptScalarFieldEnum]


export const ProcessingCheckpointScalarFieldEnum = {
  id: 'id',
  processingDocumentId: 'processingDocumentId',
  step: 'step',
  status: 'status',
  stateJson: 'stateJson',
  createdAt: 'createdAt'
} as const

export type ProcessingCheckpointScalarFieldEnum = (typeof ProcessingCheckpointScalarFieldEnum)[keyof typeof ProcessingCheckpointScalarFieldEnum]


export const SplitPlanScalarFieldEnum = {
  id: 'id',
  processingDocumentId: 'processingDocumentId',
  tenantId: 'tenantId',
  companyId: 'companyId',
  method: 'method',
  schemaVersion: 'schemaVersion',
  rangesJson: 'rangesJson',
  supersededAt: 'supersededAt',
  createdById: 'createdById',
  createdAt: 'createdAt'
} as const

export type SplitPlanScalarFieldEnum = (typeof SplitPlanScalarFieldEnum)[keyof typeof SplitPlanScalarFieldEnum]


export const DocumentStateEventScalarFieldEnum = {
  id: 'id',
  processingDocumentId: 'processingDocumentId',
  tenantId: 'tenantId',
  companyId: 'companyId',
  eventType: 'eventType',
  fromState: 'fromState',
  toState: 'toState',
  reason: 'reason',
  metadata: 'metadata',
  actorUserId: 'actorUserId',
  actorServiceId: 'actorServiceId',
  createdAt: 'createdAt'
} as const

export type DocumentStateEventScalarFieldEnum = (typeof DocumentStateEventScalarFieldEnum)[keyof typeof DocumentStateEventScalarFieldEnum]


export const DocumentDerivedFileScalarFieldEnum = {
  id: 'id',
  processingDocumentId: 'processingDocumentId',
  tenantId: 'tenantId',
  companyId: 'companyId',
  kind: 'kind',
  storageKey: 'storageKey',
  mimeType: 'mimeType',
  sizeBytes: 'sizeBytes',
  fingerprint: 'fingerprint',
  createdAt: 'createdAt'
} as const

export type DocumentDerivedFileScalarFieldEnum = (typeof DocumentDerivedFileScalarFieldEnum)[keyof typeof DocumentDerivedFileScalarFieldEnum]


export const IdempotencyRecordScalarFieldEnum = {
  key: 'key',
  tenantId: 'tenantId',
  endpoint: 'endpoint',
  method: 'method',
  requestHash: 'requestHash',
  response: 'response',
  statusCode: 'statusCode',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt'
} as const

export type IdempotencyRecordScalarFieldEnum = (typeof IdempotencyRecordScalarFieldEnum)[keyof typeof IdempotencyRecordScalarFieldEnum]


export const WebhookSubscriptionScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  url: 'url',
  events: 'events',
  secret: 'secret',
  isActive: 'isActive',
  lastDeliveryAt: 'lastDeliveryAt',
  lastDeliveryStatus: 'lastDeliveryStatus',
  failureCount: 'failureCount',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WebhookSubscriptionScalarFieldEnum = (typeof WebhookSubscriptionScalarFieldEnum)[keyof typeof WebhookSubscriptionScalarFieldEnum]


export const ExchangeRateScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  sourceCurrency: 'sourceCurrency',
  targetCurrency: 'targetCurrency',
  rate: 'rate',
  inverseRate: 'inverseRate',
  rateDate: 'rateDate',
  rateType: 'rateType',
  isManualOverride: 'isManualOverride',
  manualReason: 'manualReason',
  createdById: 'createdById',
  fetchedAt: 'fetchedAt',
  sourceRef: 'sourceRef',
  sourceHash: 'sourceHash',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ExchangeRateScalarFieldEnum = (typeof ExchangeRateScalarFieldEnum)[keyof typeof ExchangeRateScalarFieldEnum]


export const BankAccountScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  companyId: 'companyId',
  name: 'name',
  accountNumber: 'accountNumber',
  currency: 'currency',
  bankProvider: 'bankProvider',
  externalId: 'externalId',
  lastSyncAt: 'lastSyncAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt'
} as const

export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


export const BankTransactionScalarFieldEnum = {
  id: 'id',
  bankAccountId: 'bankAccountId',
  tenantId: 'tenantId',
  transactionDate: 'transactionDate',
  valueDate: 'valueDate',
  description: 'description',
  reference: 'reference',
  amount: 'amount',
  currency: 'currency',
  runningBalance: 'runningBalance',
  transactionType: 'transactionType',
  importBatchId: 'importBatchId',
  externalId: 'externalId',
  reconciliationStatus: 'reconciliationStatus',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BankTransactionScalarFieldEnum = (typeof BankTransactionScalarFieldEnum)[keyof typeof BankTransactionScalarFieldEnum]


export const MatchGroupScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  companyId: 'companyId',
  matchType: 'matchType',
  matchMethod: 'matchMethod',
  matchAlgorithmVersion: 'matchAlgorithmVersion',
  confidence: 'confidence',
  matchReasons: 'matchReasons',
  status: 'status',
  fxConversionJson: 'fxConversionJson',
  createdAt: 'createdAt',
  confirmedById: 'confirmedById',
  confirmedAt: 'confirmedAt',
  rejectedById: 'rejectedById',
  rejectedAt: 'rejectedAt',
  rejectionReason: 'rejectionReason'
} as const

export type MatchGroupScalarFieldEnum = (typeof MatchGroupScalarFieldEnum)[keyof typeof MatchGroupScalarFieldEnum]


export const MatchGroupItemScalarFieldEnum = {
  id: 'id',
  matchGroupId: 'matchGroupId',
  bankTransactionId: 'bankTransactionId',
  documentRevisionId: 'documentRevisionId',
  allocatedAmount: 'allocatedAmount',
  allocationCurrency: 'allocationCurrency'
} as const

export type MatchGroupItemScalarFieldEnum = (typeof MatchGroupItemScalarFieldEnum)[keyof typeof MatchGroupItemScalarFieldEnum]


export const ReconciliationPeriodScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  companyId: 'companyId',
  bankAccountId: 'bankAccountId',
  periodStart: 'periodStart',
  periodEnd: 'periodEnd',
  status: 'status',
  lockedById: 'lockedById',
  lockedAt: 'lockedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReconciliationPeriodScalarFieldEnum = (typeof ReconciliationPeriodScalarFieldEnum)[keyof typeof ReconciliationPeriodScalarFieldEnum]


export const ClientPortalUserScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  companyId: 'companyId',
  email: 'email',
  name: 'name',
  passwordHash: 'passwordHash',
  mfaEnabled: 'mfaEnabled',
  mfaSecret: 'mfaSecret',
  isActive: 'isActive',
  lastLoginAt: 'lastLoginAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ClientPortalUserScalarFieldEnum = (typeof ClientPortalUserScalarFieldEnum)[keyof typeof ClientPortalUserScalarFieldEnum]


export const ClientRequestScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  companyId: 'companyId',
  title: 'title',
  description: 'description',
  dueDate: 'dueDate',
  status: 'status',
  priority: 'priority',
  createdById: 'createdById',
  createdAt: 'createdAt',
  resolvedById: 'resolvedById',
  resolvedAt: 'resolvedAt'
} as const

export type ClientRequestScalarFieldEnum = (typeof ClientRequestScalarFieldEnum)[keyof typeof ClientRequestScalarFieldEnum]


export const CommunicationScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  companyId: 'companyId',
  clientRequestId: 'clientRequestId',
  direction: 'direction',
  channel: 'channel',
  subject: 'subject',
  body: 'body',
  fromUserId: 'fromUserId',
  fromClientUserId: 'fromClientUserId',
  toEmails: 'toEmails',
  externalMessageId: 'externalMessageId',
  threadId: 'threadId',
  sentAt: 'sentAt',
  readAt: 'readAt',
  createdAt: 'createdAt'
} as const

export type CommunicationScalarFieldEnum = (typeof CommunicationScalarFieldEnum)[keyof typeof CommunicationScalarFieldEnum]


export const AccountingIntegrationScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  companyId: 'companyId',
  provider: 'provider',
  accessToken: 'accessToken',
  refreshToken: 'refreshToken',
  tokenExpiresAt: 'tokenExpiresAt',
  isActive: 'isActive',
  lastSyncAt: 'lastSyncAt',
  lastError: 'lastError',
  settings: 'settings',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AccountingIntegrationScalarFieldEnum = (typeof AccountingIntegrationScalarFieldEnum)[keyof typeof AccountingIntegrationScalarFieldEnum]


export const ExternalPostingScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  documentRevisionId: 'documentRevisionId',
  integrationId: 'integrationId',
  idempotencyKey: 'idempotencyKey',
  externalId: 'externalId',
  externalType: 'externalType',
  externalUrl: 'externalUrl',
  status: 'status',
  attemptCount: 'attemptCount',
  lastAttemptAt: 'lastAttemptAt',
  lastError: 'lastError',
  createdAt: 'createdAt',
  postedAt: 'postedAt'
} as const

export type ExternalPostingScalarFieldEnum = (typeof ExternalPostingScalarFieldEnum)[keyof typeof ExternalPostingScalarFieldEnum]


export const FieldMappingScalarFieldEnum = {
  id: 'id',
  integrationId: 'integrationId',
  sourceField: 'sourceField',
  targetField: 'targetField',
  transformRule: 'transformRule',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FieldMappingScalarFieldEnum = (typeof FieldMappingScalarFieldEnum)[keyof typeof FieldMappingScalarFieldEnum]


export const TenantBackupScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  backupType: 'backupType',
  status: 'status',
  storageKey: 'storageKey',
  manifestJson: 'manifestJson',
  databaseSizeBytes: 'databaseSizeBytes',
  filesSizeBytes: 'filesSizeBytes',
  totalSizeBytes: 'totalSizeBytes',
  filesCount: 'filesCount',
  progress: 'progress',
  currentStep: 'currentStep',
  errorMessage: 'errorMessage',
  errorDetails: 'errorDetails',
  restoredAt: 'restoredAt',
  restoredById: 'restoredById',
  retentionDays: 'retentionDays',
  expiresAt: 'expiresAt',
  createdById: 'createdById',
  createdAt: 'createdAt',
  completedAt: 'completedAt',
  deletedAt: 'deletedAt'
} as const

export type TenantBackupScalarFieldEnum = (typeof TenantBackupScalarFieldEnum)[keyof typeof TenantBackupScalarFieldEnum]


export const BackupScheduleScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  cronPattern: 'cronPattern',
  isEnabled: 'isEnabled',
  timezone: 'timezone',
  retentionDays: 'retentionDays',
  maxBackups: 'maxBackups',
  lastRunAt: 'lastRunAt',
  lastBackupId: 'lastBackupId',
  nextRunAt: 'nextRunAt',
  lastError: 'lastError',
  consecutiveFailures: 'consecutiveFailures',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BackupScheduleScalarFieldEnum = (typeof BackupScheduleScalarFieldEnum)[keyof typeof BackupScheduleScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'TenantStatus'
 */
export type EnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus'>
    


/**
 * Reference to a field of type 'TenantStatus[]'
 */
export type ListEnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'EntityType'
 */
export type EnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType'>
    


/**
 * Reference to a field of type 'EntityType[]'
 */
export type ListEnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType[]'>
    


/**
 * Reference to a field of type 'CompanyStatus'
 */
export type EnumCompanyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatus'>
    


/**
 * Reference to a field of type 'CompanyStatus[]'
 */
export type ListEnumCompanyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatus[]'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'AddressType'
 */
export type EnumAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressType'>
    


/**
 * Reference to a field of type 'AddressType[]'
 */
export type ListEnumAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressType[]'>
    


/**
 * Reference to a field of type 'ContactType'
 */
export type EnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType'>
    


/**
 * Reference to a field of type 'ContactType[]'
 */
export type ListEnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType[]'>
    


/**
 * Reference to a field of type 'IdentificationType'
 */
export type EnumIdentificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentificationType'>
    


/**
 * Reference to a field of type 'IdentificationType[]'
 */
export type ListEnumIdentificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentificationType[]'>
    


/**
 * Reference to a field of type 'OfficerRole'
 */
export type EnumOfficerRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfficerRole'>
    


/**
 * Reference to a field of type 'OfficerRole[]'
 */
export type ListEnumOfficerRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfficerRole[]'>
    


/**
 * Reference to a field of type 'AuditAction'
 */
export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


/**
 * Reference to a field of type 'AuditAction[]'
 */
export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


/**
 * Reference to a field of type 'ChangeSource'
 */
export type EnumChangeSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeSource'>
    


/**
 * Reference to a field of type 'ChangeSource[]'
 */
export type ListEnumChangeSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeSource[]'>
    


/**
 * Reference to a field of type 'ConnectorType'
 */
export type EnumConnectorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectorType'>
    


/**
 * Reference to a field of type 'ConnectorType[]'
 */
export type ListEnumConnectorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectorType[]'>
    


/**
 * Reference to a field of type 'ConnectorProvider'
 */
export type EnumConnectorProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectorProvider'>
    


/**
 * Reference to a field of type 'ConnectorProvider[]'
 */
export type ListEnumConnectorProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectorProvider[]'>
    


/**
 * Reference to a field of type 'DocumentTemplateCategory'
 */
export type EnumDocumentTemplateCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentTemplateCategory'>
    


/**
 * Reference to a field of type 'DocumentTemplateCategory[]'
 */
export type ListEnumDocumentTemplateCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentTemplateCategory[]'>
    


/**
 * Reference to a field of type 'GeneratedDocumentStatus'
 */
export type EnumGeneratedDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GeneratedDocumentStatus'>
    


/**
 * Reference to a field of type 'GeneratedDocumentStatus[]'
 */
export type ListEnumGeneratedDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GeneratedDocumentStatus[]'>
    


/**
 * Reference to a field of type 'DocumentCommentStatus'
 */
export type EnumDocumentCommentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentCommentStatus'>
    


/**
 * Reference to a field of type 'DocumentCommentStatus[]'
 */
export type ListEnumDocumentCommentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentCommentStatus[]'>
    


/**
 * Reference to a field of type 'PipelineStatus'
 */
export type EnumPipelineStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PipelineStatus'>
    


/**
 * Reference to a field of type 'PipelineStatus[]'
 */
export type ListEnumPipelineStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PipelineStatus[]'>
    


/**
 * Reference to a field of type 'ProcessingPriority'
 */
export type EnumProcessingPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingPriority'>
    


/**
 * Reference to a field of type 'ProcessingPriority[]'
 */
export type ListEnumProcessingPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingPriority[]'>
    


/**
 * Reference to a field of type 'DuplicateStatus'
 */
export type EnumDuplicateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DuplicateStatus'>
    


/**
 * Reference to a field of type 'DuplicateStatus[]'
 */
export type ListEnumDuplicateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DuplicateStatus[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'UploadSource'
 */
export type EnumUploadSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UploadSource'>
    


/**
 * Reference to a field of type 'UploadSource[]'
 */
export type ListEnumUploadSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UploadSource[]'>
    


/**
 * Reference to a field of type 'DocumentLinkType'
 */
export type EnumDocumentLinkTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentLinkType'>
    


/**
 * Reference to a field of type 'DocumentLinkType[]'
 */
export type ListEnumDocumentLinkTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentLinkType[]'>
    


/**
 * Reference to a field of type 'ExtractionType'
 */
export type EnumExtractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExtractionType'>
    


/**
 * Reference to a field of type 'ExtractionType[]'
 */
export type ListEnumExtractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExtractionType[]'>
    


/**
 * Reference to a field of type 'RevisionType'
 */
export type EnumRevisionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionType'>
    


/**
 * Reference to a field of type 'RevisionType[]'
 */
export type ListEnumRevisionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionType[]'>
    


/**
 * Reference to a field of type 'RevisionStatus'
 */
export type EnumRevisionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionStatus'>
    


/**
 * Reference to a field of type 'RevisionStatus[]'
 */
export type ListEnumRevisionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionStatus[]'>
    


/**
 * Reference to a field of type 'DocumentCategory'
 */
export type EnumDocumentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentCategory'>
    


/**
 * Reference to a field of type 'DocumentCategory[]'
 */
export type ListEnumDocumentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentCategory[]'>
    


/**
 * Reference to a field of type 'DocumentSubCategory'
 */
export type EnumDocumentSubCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentSubCategory'>
    


/**
 * Reference to a field of type 'DocumentSubCategory[]'
 */
export type ListEnumDocumentSubCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentSubCategory[]'>
    


/**
 * Reference to a field of type 'RoundingMode'
 */
export type EnumRoundingModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoundingMode'>
    


/**
 * Reference to a field of type 'RoundingMode[]'
 */
export type ListEnumRoundingModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoundingMode[]'>
    


/**
 * Reference to a field of type 'GstTreatment'
 */
export type EnumGstTreatmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GstTreatment'>
    


/**
 * Reference to a field of type 'GstTreatment[]'
 */
export type ListEnumGstTreatmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GstTreatment[]'>
    


/**
 * Reference to a field of type 'ExchangeRateSource'
 */
export type EnumExchangeRateSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExchangeRateSource'>
    


/**
 * Reference to a field of type 'ExchangeRateSource[]'
 */
export type ListEnumExchangeRateSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExchangeRateSource[]'>
    


/**
 * Reference to a field of type 'ValidationStatus'
 */
export type EnumValidationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ValidationStatus'>
    


/**
 * Reference to a field of type 'ValidationStatus[]'
 */
export type ListEnumValidationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ValidationStatus[]'>
    


/**
 * Reference to a field of type 'RevisionPostingStatus'
 */
export type EnumRevisionPostingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionPostingStatus'>
    


/**
 * Reference to a field of type 'RevisionPostingStatus[]'
 */
export type ListEnumRevisionPostingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionPostingStatus[]'>
    


/**
 * Reference to a field of type 'RevisionReconciliationStatus'
 */
export type EnumRevisionReconciliationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionReconciliationStatus'>
    


/**
 * Reference to a field of type 'RevisionReconciliationStatus[]'
 */
export type ListEnumRevisionReconciliationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevisionReconciliationStatus[]'>
    


/**
 * Reference to a field of type 'DuplicateAction'
 */
export type EnumDuplicateActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DuplicateAction'>
    


/**
 * Reference to a field of type 'DuplicateAction[]'
 */
export type ListEnumDuplicateActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DuplicateAction[]'>
    


/**
 * Reference to a field of type 'ProcessingStep'
 */
export type EnumProcessingStepFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStep'>
    


/**
 * Reference to a field of type 'ProcessingStep[]'
 */
export type ListEnumProcessingStepFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStep[]'>
    


/**
 * Reference to a field of type 'AttemptStatus'
 */
export type EnumAttemptStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttemptStatus'>
    


/**
 * Reference to a field of type 'AttemptStatus[]'
 */
export type ListEnumAttemptStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttemptStatus[]'>
    


/**
 * Reference to a field of type 'CheckpointStatus'
 */
export type EnumCheckpointStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckpointStatus'>
    


/**
 * Reference to a field of type 'CheckpointStatus[]'
 */
export type ListEnumCheckpointStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckpointStatus[]'>
    


/**
 * Reference to a field of type 'SplitMethod'
 */
export type EnumSplitMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SplitMethod'>
    


/**
 * Reference to a field of type 'SplitMethod[]'
 */
export type ListEnumSplitMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SplitMethod[]'>
    


/**
 * Reference to a field of type 'DerivedFileKind'
 */
export type EnumDerivedFileKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DerivedFileKind'>
    


/**
 * Reference to a field of type 'DerivedFileKind[]'
 */
export type ListEnumDerivedFileKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DerivedFileKind[]'>
    


/**
 * Reference to a field of type 'ExchangeRateType'
 */
export type EnumExchangeRateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExchangeRateType'>
    


/**
 * Reference to a field of type 'ExchangeRateType[]'
 */
export type ListEnumExchangeRateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExchangeRateType[]'>
    


/**
 * Reference to a field of type 'BankTransactionType'
 */
export type EnumBankTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankTransactionType'>
    


/**
 * Reference to a field of type 'BankTransactionType[]'
 */
export type ListEnumBankTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankTransactionType[]'>
    


/**
 * Reference to a field of type 'ReconciliationStatus'
 */
export type EnumReconciliationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReconciliationStatus'>
    


/**
 * Reference to a field of type 'ReconciliationStatus[]'
 */
export type ListEnumReconciliationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReconciliationStatus[]'>
    


/**
 * Reference to a field of type 'MatchType'
 */
export type EnumMatchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchType'>
    


/**
 * Reference to a field of type 'MatchType[]'
 */
export type ListEnumMatchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchType[]'>
    


/**
 * Reference to a field of type 'MatchMethod'
 */
export type EnumMatchMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchMethod'>
    


/**
 * Reference to a field of type 'MatchMethod[]'
 */
export type ListEnumMatchMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchMethod[]'>
    


/**
 * Reference to a field of type 'MatchGroupStatus'
 */
export type EnumMatchGroupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchGroupStatus'>
    


/**
 * Reference to a field of type 'MatchGroupStatus[]'
 */
export type ListEnumMatchGroupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchGroupStatus[]'>
    


/**
 * Reference to a field of type 'PeriodStatus'
 */
export type EnumPeriodStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PeriodStatus'>
    


/**
 * Reference to a field of type 'PeriodStatus[]'
 */
export type ListEnumPeriodStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PeriodStatus[]'>
    


/**
 * Reference to a field of type 'ClientRequestStatus'
 */
export type EnumClientRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientRequestStatus'>
    


/**
 * Reference to a field of type 'ClientRequestStatus[]'
 */
export type ListEnumClientRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientRequestStatus[]'>
    


/**
 * Reference to a field of type 'RequestPriority'
 */
export type EnumRequestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestPriority'>
    


/**
 * Reference to a field of type 'RequestPriority[]'
 */
export type ListEnumRequestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestPriority[]'>
    


/**
 * Reference to a field of type 'CommunicationDirection'
 */
export type EnumCommunicationDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationDirection'>
    


/**
 * Reference to a field of type 'CommunicationDirection[]'
 */
export type ListEnumCommunicationDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationDirection[]'>
    


/**
 * Reference to a field of type 'CommunicationChannel'
 */
export type EnumCommunicationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationChannel'>
    


/**
 * Reference to a field of type 'CommunicationChannel[]'
 */
export type ListEnumCommunicationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationChannel[]'>
    


/**
 * Reference to a field of type 'AccountingProvider'
 */
export type EnumAccountingProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountingProvider'>
    


/**
 * Reference to a field of type 'AccountingProvider[]'
 */
export type ListEnumAccountingProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountingProvider[]'>
    


/**
 * Reference to a field of type 'PostingStatus'
 */
export type EnumPostingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostingStatus'>
    


/**
 * Reference to a field of type 'PostingStatus[]'
 */
export type ListEnumPostingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostingStatus[]'>
    


/**
 * Reference to a field of type 'BackupType'
 */
export type EnumBackupTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BackupType'>
    


/**
 * Reference to a field of type 'BackupType[]'
 */
export type ListEnumBackupTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BackupType[]'>
    


/**
 * Reference to a field of type 'BackupStatus'
 */
export type EnumBackupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BackupStatus'>
    


/**
 * Reference to a field of type 'BackupStatus[]'
 */
export type ListEnumBackupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BackupStatus[]'>
    


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'BigInt[]'
 */
export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  tenant?: Prisma.TenantOmit
  role?: Prisma.RoleOmit
  permission?: Prisma.PermissionOmit
  rolePermission?: Prisma.RolePermissionOmit
  userRoleAssignment?: Prisma.UserRoleAssignmentOmit
  user?: Prisma.UserOmit
  userCompanyAssignment?: Prisma.UserCompanyAssignmentOmit
  company?: Prisma.CompanyOmit
  companyFormerName?: Prisma.CompanyFormerNameOmit
  companyAddress?: Prisma.CompanyAddressOmit
  contact?: Prisma.ContactOmit
  companyContact?: Prisma.CompanyContactOmit
  companyOfficer?: Prisma.CompanyOfficerOmit
  shareCapital?: Prisma.ShareCapitalOmit
  companyShareholder?: Prisma.CompanyShareholderOmit
  companyCharge?: Prisma.CompanyChargeOmit
  document?: Prisma.DocumentOmit
  auditLog?: Prisma.AuditLogOmit
  connector?: Prisma.ConnectorOmit
  tenantConnectorAccess?: Prisma.TenantConnectorAccessOmit
  connectorUsageLog?: Prisma.ConnectorUsageLogOmit
  noteTab?: Prisma.NoteTabOmit
  documentTemplate?: Prisma.DocumentTemplateOmit
  generatedDocument?: Prisma.GeneratedDocumentOmit
  documentSection?: Prisma.DocumentSectionOmit
  documentShare?: Prisma.DocumentShareOmit
  tenantLetterhead?: Prisma.TenantLetterheadOmit
  documentComment?: Prisma.DocumentCommentOmit
  documentDraft?: Prisma.DocumentDraftOmit
  templatePartial?: Prisma.TemplatePartialOmit
  aiConversation?: Prisma.AiConversationOmit
  processingDocument?: Prisma.ProcessingDocumentOmit
  documentLink?: Prisma.DocumentLinkOmit
  documentPage?: Prisma.DocumentPageOmit
  documentExtraction?: Prisma.DocumentExtractionOmit
  documentRevision?: Prisma.DocumentRevisionOmit
  documentRevisionLineItem?: Prisma.DocumentRevisionLineItemOmit
  vendorAlias?: Prisma.VendorAliasOmit
  duplicateDecision?: Prisma.DuplicateDecisionOmit
  processingAttempt?: Prisma.ProcessingAttemptOmit
  processingCheckpoint?: Prisma.ProcessingCheckpointOmit
  splitPlan?: Prisma.SplitPlanOmit
  documentStateEvent?: Prisma.DocumentStateEventOmit
  documentDerivedFile?: Prisma.DocumentDerivedFileOmit
  idempotencyRecord?: Prisma.IdempotencyRecordOmit
  webhookSubscription?: Prisma.WebhookSubscriptionOmit
  exchangeRate?: Prisma.ExchangeRateOmit
  bankAccount?: Prisma.BankAccountOmit
  bankTransaction?: Prisma.BankTransactionOmit
  matchGroup?: Prisma.MatchGroupOmit
  matchGroupItem?: Prisma.MatchGroupItemOmit
  reconciliationPeriod?: Prisma.ReconciliationPeriodOmit
  clientPortalUser?: Prisma.ClientPortalUserOmit
  clientRequest?: Prisma.ClientRequestOmit
  communication?: Prisma.CommunicationOmit
  accountingIntegration?: Prisma.AccountingIntegrationOmit
  externalPosting?: Prisma.ExternalPostingOmit
  fieldMapping?: Prisma.FieldMappingOmit
  tenantBackup?: Prisma.TenantBackupOmit
  backupSchedule?: Prisma.BackupScheduleOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

