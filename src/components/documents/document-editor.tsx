'use client';

import { useEditor, EditorContent, Editor } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import { Link as TiptapLink } from '@tiptap/extension-link';
import { Underline } from '@tiptap/extension-underline';
import { TextStyle } from '@tiptap/extension-text-style';
import { Color } from '@tiptap/extension-color';
import { useEffect, useState, useCallback, useRef, useMemo, forwardRef, useImperativeHandle } from 'react';
import {
  Bold,
  Italic,
  Underline as UnderlineIcon,
  List,
  ListOrdered,
  Link as LinkIcon,
  Unlink,
  Strikethrough,
  ALargeSmall,
  Palette,
  ChevronDown,
  Heading1,
  Heading2,
  Heading3,
  Minus,
  RemoveFormatting,
  Undo2,
  Redo2,
  Braces,
  SplitSquareHorizontal,
} from 'lucide-react';

// ============================================================================
// Types & Constants
// ============================================================================

export interface DocumentEditorProps {
  value?: string;
  valueJson?: Record<string, unknown> | null;
  onChange?: (html: string, json: Record<string, unknown>) => void;
  onAutoSave?: (html: string, json: Record<string, unknown>) => void;
  readOnly?: boolean;
  placeholder?: string;
  minHeight?: number;
  className?: string;
  autoSaveInterval?: number; // ms, 0 to disable
  showPlaceholderButton?: boolean;
  availablePlaceholders?: PlaceholderOption[];
}

export interface DocumentEditorRef {
  getContent: () => { html: string; json: Record<string, unknown> };
  setContent: (html: string) => void;
  insertPlaceholder: (placeholder: string) => void;
  insertPageBreak: () => void;
  insertContent: (content: string) => void;
  replaceSelection: (content: string) => void;
  getSelectedText: () => string | undefined;
  getSurroundingContent: () => string | undefined;
  undo: () => void;
  redo: () => void;
  canUndo: () => boolean;
  canRedo: () => boolean;
  focus: () => void;
}

interface ToolbarButtonProps {
  onClick: () => void;
  isActive?: boolean;
  disabled?: boolean;
  children: React.ReactNode;
  title: string;
}

interface PlaceholderOption {
  key: string;
  label: string;
  category: string;
}

const FONT_SIZES = ['10', '12', '14', '16', '18', '20', '24', '28', '32'];

const TEXT_COLORS = [
  { label: 'Default', value: '' },
  { label: 'Gray', value: '#6b7280' },
  { label: 'Red', value: '#dc2626' },
  { label: 'Orange', value: '#ea580c' },
  { label: 'Green', value: '#16a34a' },
  { label: 'Blue', value: '#2563eb' },
  { label: 'Purple', value: '#9333ea' },
];

const DEFAULT_PLACEHOLDERS: PlaceholderOption[] = [
  { key: 'company.name', label: 'Company Name', category: 'Company' },
  { key: 'company.uen', label: 'Company UEN', category: 'Company' },
  { key: 'company.registeredAddress', label: 'Registered Address', category: 'Company' },
  { key: 'company.incorporationDate', label: 'Incorporation Date', category: 'Company' },
  { key: 'system.currentDate', label: 'Current Date', category: 'System' },
  { key: 'system.generatedBy', label: 'Generated By', category: 'System' },
  { key: 'custom.resolutionNumber', label: 'Resolution Number', category: 'Custom' },
];

// ============================================================================
// Toolbar Components
// ============================================================================

function ToolbarButton({
  onClick,
  isActive,
  disabled,
  children,
  title,
}: ToolbarButtonProps) {
  return (
    <button
      type="button"
      onClick={onClick}
      disabled={disabled}
      title={title}
      className={`p-1.5 rounded transition-colors ${
        isActive
          ? 'bg-background-tertiary text-text-primary'
          : 'text-text-muted hover:bg-background-secondary hover:text-text-primary'
      } ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
    >
      {children}
    </button>
  );
}

interface DropdownProps {
  trigger: React.ReactNode;
  children: React.ReactNode;
  isOpen: boolean;
  onToggle: () => void;
  onClose: () => void;
}

function Dropdown({ trigger, children, isOpen, onToggle, onClose }: DropdownProps) {
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (ref.current && !ref.current.contains(e.target as Node)) {
        onClose();
      }
    };
    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [isOpen, onClose]);

  return (
    <div className="relative" ref={ref}>
      <button
        type="button"
        onClick={onToggle}
        className="flex items-center gap-0.5 p-1.5 rounded text-text-muted hover:bg-background-secondary hover:text-text-primary transition-colors"
      >
        {trigger}
        <ChevronDown className="w-3 h-3" />
      </button>
      {isOpen && (
        <div className="absolute top-full left-0 mt-1 py-1 bg-background-elevated border border-border-primary rounded-md shadow-elevation-2 z-10 min-w-[140px] max-h-[300px] overflow-y-auto">
          {children}
        </div>
      )}
    </div>
  );
}

interface DocumentToolbarProps {
  editor: Editor | null;
  showPlaceholderButton?: boolean;
  availablePlaceholders?: PlaceholderOption[];
  onInsertPlaceholder?: (placeholder: string) => void;
  onInsertPageBreak?: () => void;
}

function DocumentToolbar({
  editor,
  showPlaceholderButton = true,
  availablePlaceholders = DEFAULT_PLACEHOLDERS,
  onInsertPlaceholder,
  onInsertPageBreak,
}: DocumentToolbarProps) {
  const [showLinkInput, setShowLinkInput] = useState(false);
  const [linkUrl, setLinkUrl] = useState('');
  const [showFontSize, setShowFontSize] = useState(false);
  const [showColor, setShowColor] = useState(false);
  const [showPlaceholders, setShowPlaceholders] = useState(false);

  const setLink = useCallback(() => {
    if (!editor) return;

    if (linkUrl === '') {
      editor.chain().focus().extendMarkRange('link').unsetLink().run();
    } else {
      const url = linkUrl.startsWith('http') ? linkUrl : `https://${linkUrl}`;
      editor
        .chain()
        .focus()
        .extendMarkRange('link')
        .setLink({ href: url })
        .run();
    }
    setShowLinkInput(false);
    setLinkUrl('');
  }, [editor, linkUrl]);

  const handleLinkClick = () => {
    if (!editor) return;

    const previousUrl = editor.getAttributes('link').href;
    if (previousUrl) {
      setLinkUrl(previousUrl);
    }
    setShowLinkInput(true);
  };

  const setFontSize = (size: string) => {
    if (!editor) return;
    editor.chain().focus().setMark('textStyle', { fontSize: `${size}px` }).run();
    setShowFontSize(false);
  };

  const setColor = (color: string) => {
    if (!editor) return;
    if (color === '') {
      editor.chain().focus().unsetColor().run();
    } else {
      editor.chain().focus().setColor(color).run();
    }
    setShowColor(false);
  };

  const applyHeading = (level: 1 | 2 | 3) => {
    if (!editor) return;
    editor.chain().focus().toggleHeading({ level }).run();
  };

  const resetToNormal = () => {
    if (!editor) return;
    editor
      .chain()
      .focus()
      .unsetBold()
      .unsetItalic()
      .unsetUnderline()
      .unsetStrike()
      .unsetColor()
      .unsetMark('textStyle')
      .setParagraph()
      .run();
  };

  const insertDivider = () => {
    if (!editor) return;
    editor.chain().focus().setHorizontalRule().run();
  };

  const handlePlaceholderInsert = (key: string) => {
    setShowPlaceholders(false);
    onInsertPlaceholder?.(key);
  };

  // Group placeholders by category
  const placeholdersByCategory = useMemo(() => {
    const grouped: Record<string, PlaceholderOption[]> = {};
    for (const p of availablePlaceholders) {
      if (!grouped[p.category]) {
        grouped[p.category] = [];
      }
      grouped[p.category].push(p);
    }
    return grouped;
  }, [availablePlaceholders]);

  if (!editor) return null;

  return (
    <div className="flex items-center gap-0.5 p-1 border-b border-border-primary bg-background-secondary flex-wrap">
      {/* Undo/Redo */}
      <ToolbarButton
        onClick={() => editor.chain().focus().undo().run()}
        disabled={!editor.can().undo()}
        title="Undo (Ctrl+Z)"
      >
        <Undo2 className="w-4 h-4" />
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().redo().run()}
        disabled={!editor.can().redo()}
        title="Redo (Ctrl+Y)"
      >
        <Redo2 className="w-4 h-4" />
      </ToolbarButton>

      <div className="w-px h-5 bg-border-primary mx-1" />

      {/* Font Size */}
      <Dropdown
        trigger={<ALargeSmall className="w-4 h-4" />}
        isOpen={showFontSize}
        onToggle={() => setShowFontSize(!showFontSize)}
        onClose={() => setShowFontSize(false)}
      >
        <div className="grid grid-cols-3 gap-0.5 p-1 w-[100px]">
          {FONT_SIZES.map((size) => (
            <button
              key={size}
              type="button"
              onClick={() => setFontSize(size)}
              className="px-2 py-1 text-xs text-center hover:bg-background-tertiary transition-colors rounded"
            >
              {size}
            </button>
          ))}
        </div>
      </Dropdown>

      {/* Text Color */}
      <Dropdown
        trigger={
          <div className="flex items-center">
            <Palette className="w-4 h-4" />
            <div
              className="w-2 h-2 rounded-full ml-0.5 border border-border-primary"
              style={{
                backgroundColor: editor.getAttributes('textStyle').color || 'currentColor',
              }}
            />
          </div>
        }
        isOpen={showColor}
        onToggle={() => setShowColor(!showColor)}
        onClose={() => setShowColor(false)}
      >
        {TEXT_COLORS.map((color) => (
          <button
            key={color.value || 'default'}
            type="button"
            onClick={() => setColor(color.value)}
            className="w-full px-3 py-1.5 text-left text-xs hover:bg-background-tertiary transition-colors flex items-center gap-2"
          >
            <div
              className="w-3 h-3 rounded-full border border-border-primary"
              style={{ backgroundColor: color.value || 'var(--text-primary)' }}
            />
            {color.label}
          </button>
        ))}
      </Dropdown>

      <div className="w-px h-5 bg-border-primary mx-1" />

      {/* Headings */}
      <ToolbarButton
        onClick={() => applyHeading(1)}
        isActive={editor.isActive('heading', { level: 1 })}
        title="Heading 1"
      >
        <Heading1 className="w-4 h-4" />
      </ToolbarButton>
      <ToolbarButton
        onClick={() => applyHeading(2)}
        isActive={editor.isActive('heading', { level: 2 })}
        title="Heading 2"
      >
        <Heading2 className="w-4 h-4" />
      </ToolbarButton>
      <ToolbarButton
        onClick={() => applyHeading(3)}
        isActive={editor.isActive('heading', { level: 3 })}
        title="Heading 3"
      >
        <Heading3 className="w-4 h-4" />
      </ToolbarButton>

      {/* Reset to Normal */}
      <ToolbarButton
        onClick={resetToNormal}
        title="Reset to Normal Text"
      >
        <RemoveFormatting className="w-4 h-4" />
      </ToolbarButton>

      <div className="w-px h-5 bg-border-primary mx-1" />

      {/* Text formatting */}
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleBold().run()}
        isActive={editor.isActive('bold')}
        title="Bold (Ctrl+B)"
      >
        <Bold className="w-4 h-4" />
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().toggleItalic().run()}
        isActive={editor.isActive('italic')}
        title="Italic (Ctrl+I)"
      >
        <Italic className="w-4 h-4" />
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().toggleUnderline().run()}
        isActive={editor.isActive('underline')}
        title="Underline (Ctrl+U)"
      >
        <UnderlineIcon className="w-4 h-4" />
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().toggleStrike().run()}
        isActive={editor.isActive('strike')}
        title="Strikethrough"
      >
        <Strikethrough className="w-4 h-4" />
      </ToolbarButton>

      <div className="w-px h-5 bg-border-primary mx-1" />

      {/* Lists */}
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleBulletList().run()}
        isActive={editor.isActive('bulletList')}
        title="Bullet List"
      >
        <List className="w-4 h-4" />
      </ToolbarButton>

      <ToolbarButton
        onClick={() => editor.chain().focus().toggleOrderedList().run()}
        isActive={editor.isActive('orderedList')}
        title="Numbered List"
      >
        <ListOrdered className="w-4 h-4" />
      </ToolbarButton>

      <div className="w-px h-5 bg-border-primary mx-1" />

      {/* Link */}
      {showLinkInput ? (
        <div className="flex items-center gap-1">
          <input
            type="text"
            value={linkUrl}
            onChange={(e) => setLinkUrl(e.target.value)}
            placeholder="Enter URL..."
            className="px-2 py-1 text-xs border border-border-primary rounded bg-background-elevated text-text-primary w-40"
            onKeyDown={(e) => {
              if (e.key === 'Enter') {
                e.preventDefault();
                setLink();
              } else if (e.key === 'Escape') {
                setShowLinkInput(false);
                setLinkUrl('');
              }
            }}
            autoFocus
          />
          <button
            type="button"
            onClick={setLink}
            className="px-2 py-1 text-xs bg-accent-primary text-white rounded hover:bg-accent-primary/90"
          >
            Set
          </button>
          <button
            type="button"
            onClick={() => {
              setShowLinkInput(false);
              setLinkUrl('');
            }}
            className="px-2 py-1 text-xs text-text-muted hover:text-text-primary"
          >
            Cancel
          </button>
        </div>
      ) : (
        <>
          <ToolbarButton
            onClick={handleLinkClick}
            isActive={editor.isActive('link')}
            title="Add Link"
          >
            <LinkIcon className="w-4 h-4" />
          </ToolbarButton>

          {editor.isActive('link') && (
            <ToolbarButton
              onClick={() => editor.chain().focus().unsetLink().run()}
              title="Remove Link"
            >
              <Unlink className="w-4 h-4" />
            </ToolbarButton>
          )}
        </>
      )}

      {/* Divider */}
      <ToolbarButton
        onClick={insertDivider}
        title="Insert Horizontal Rule"
      >
        <Minus className="w-4 h-4" />
      </ToolbarButton>

      {/* Page Break */}
      {onInsertPageBreak && (
        <ToolbarButton
          onClick={onInsertPageBreak}
          title="Insert Page Break"
        >
          <SplitSquareHorizontal className="w-4 h-4" />
        </ToolbarButton>
      )}

      {/* Placeholder Insertion */}
      {showPlaceholderButton && onInsertPlaceholder && (
        <Dropdown
          trigger={<Braces className="w-4 h-4" />}
          isOpen={showPlaceholders}
          onToggle={() => setShowPlaceholders(!showPlaceholders)}
          onClose={() => setShowPlaceholders(false)}
        >
          <div className="w-56">
            {Object.entries(placeholdersByCategory).map(([category, placeholders]) => (
              <div key={category}>
                <div className="px-3 py-1 text-2xs font-medium text-text-muted uppercase tracking-wider">
                  {category}
                </div>
                {placeholders.map((p) => (
                  <button
                    key={p.key}
                    type="button"
                    onClick={() => handlePlaceholderInsert(p.key)}
                    className="w-full px-3 py-1.5 text-left text-xs hover:bg-background-tertiary transition-colors"
                  >
                    <span className="text-text-primary">{p.label}</span>
                    <span className="text-text-muted ml-1 text-2xs">{`{{${p.key}}}`}</span>
                  </button>
                ))}
              </div>
            ))}
          </div>
        </Dropdown>
      )}
    </div>
  );
}

// ============================================================================
// Font Size Extension
// ============================================================================

const FontSize = TextStyle.extend({
  addAttributes() {
    return {
      ...this.parent?.(),
      fontSize: {
        default: null,
        parseHTML: (element) => element.style.fontSize || null,
        renderHTML: (attributes) => {
          if (!attributes.fontSize) return {};
          return { style: `font-size: ${attributes.fontSize}` };
        },
      },
    };
  },
});

// ============================================================================
// Main Document Editor Component
// ============================================================================

export const DocumentEditor = forwardRef<DocumentEditorRef, DocumentEditorProps>(
  function DocumentEditor(
    {
      value = '',
      valueJson,
      onChange,
      onAutoSave,
      readOnly = false,
      minHeight = 400,
      className = '',
      autoSaveInterval = 30000, // 30 seconds default
      showPlaceholderButton = true,
      availablePlaceholders = DEFAULT_PLACEHOLDERS,
    },
    ref
  ) {
    const autoSaveTimerRef = useRef<NodeJS.Timeout | null>(null);
    const lastSavedContentRef = useRef<string>(value);

    const editor = useEditor({
      extensions: [
        StarterKit.configure({
          heading: {
            levels: [1, 2, 3],
          },
        }),
        Underline,
        FontSize,
        Color,
        TiptapLink.configure({
          openOnClick: false,
          HTMLAttributes: {
            class: 'text-accent-primary underline',
            target: '_blank',
            rel: 'noopener noreferrer',
          },
        }),
      ],
      content: valueJson ? valueJson : value,
      editable: !readOnly,
      onUpdate: ({ editor }) => {
        const html = editor.getHTML();
        const json = editor.getJSON();
        onChange?.(html, json as Record<string, unknown>);
      },
      editorProps: {
        attributes: {
          class: `document-editor-content focus:outline-none px-6 py-4 text-text-primary`,
          style: `min-height: ${minHeight}px`,
        },
      },
      immediatelyRender: false,
    });

    // Expose methods via ref
    useImperativeHandle(ref, () => ({
      getContent: () => ({
        html: editor?.getHTML() || '',
        json: (editor?.getJSON() || {}) as Record<string, unknown>,
      }),
      setContent: (html: string) => {
        editor?.commands.setContent(html);
      },
      insertPlaceholder: (placeholder: string) => {
        editor?.chain().focus().insertContent(`{{${placeholder}}}`).run();
      },
      insertPageBreak: () => {
        editor
          ?.chain()
          .focus()
          .insertContent('<div class="page-break" style="page-break-after: always; border-top: 2px dashed #ccc; margin: 20px 0; padding-top: 10px; text-align: center; color: #999; font-size: 12px;">Page Break</div>')
          .run();
      },
      insertContent: (content: string) => {
        editor?.chain().focus().insertContent(content).run();
      },
      replaceSelection: (content: string) => {
        if (editor) {
          const { from, to } = editor.state.selection;
          editor.chain().focus().deleteRange({ from, to }).insertContent(content).run();
        }
      },
      getSelectedText: () => {
        if (!editor) return undefined;
        const { from, to } = editor.state.selection;
        if (from === to) return undefined;
        return editor.state.doc.textBetween(from, to, ' ');
      },
      getSurroundingContent: () => {
        if (!editor) return undefined;
        const { from, to } = editor.state.selection;
        const doc = editor.state.doc;
        // Get text from 200 chars before to 200 chars after selection
        const start = Math.max(0, from - 200);
        const end = Math.min(doc.content.size, to + 200);
        return doc.textBetween(start, end, ' ');
      },
      undo: () => {
        editor?.chain().focus().undo().run();
      },
      redo: () => {
        editor?.chain().focus().redo().run();
      },
      canUndo: () => editor?.can().undo() ?? false,
      canRedo: () => editor?.can().redo() ?? false,
      focus: () => {
        editor?.commands.focus();
      },
    }));

    // Auto-save functionality
    useEffect(() => {
      if (!editor || !onAutoSave || autoSaveInterval <= 0 || readOnly) return;

      autoSaveTimerRef.current = setInterval(() => {
        const currentContent = editor.getHTML();
        if (currentContent !== lastSavedContentRef.current) {
          const json = editor.getJSON();
          onAutoSave(currentContent, json as Record<string, unknown>);
          lastSavedContentRef.current = currentContent;
        }
      }, autoSaveInterval);

      return () => {
        if (autoSaveTimerRef.current) {
          clearInterval(autoSaveTimerRef.current);
        }
      };
    }, [editor, onAutoSave, autoSaveInterval, readOnly]);

    // Sync external value changes
    useEffect(() => {
      if (editor && value && value !== editor.getHTML()) {
        editor.commands.setContent(value);
        lastSavedContentRef.current = value;
      }
    }, [value, editor]);

    // Update editable state
    useEffect(() => {
      if (editor) {
        editor.setEditable(!readOnly);
      }
    }, [readOnly, editor]);

    const handleInsertPlaceholder = useCallback(
      (key: string) => {
        editor?.chain().focus().insertContent(`{{${key}}}`).run();
      },
      [editor]
    );

    const handleInsertPageBreak = useCallback(() => {
      editor
        ?.chain()
        .focus()
        .insertContent(
          '<div class="page-break" style="page-break-after: always; border-top: 2px dashed #ccc; margin: 20px 0; padding-top: 10px; text-align: center; color: #999; font-size: 12px;">--- Page Break ---</div><p></p>'
        )
        .run();
    }, [editor]);

    if (readOnly) {
      return (
        <div
          className={`border border-border-primary rounded-md bg-background-elevated overflow-hidden ${className}`}
          style={{ minHeight }}
        >
          <EditorContent editor={editor} />
        </div>
      );
    }

    return (
      <div
        className={`border border-border-primary rounded-md bg-background-elevated overflow-hidden focus-within:border-accent-primary focus-within:ring-1 focus-within:ring-accent-primary ${className}`}
      >
        <DocumentToolbar
          editor={editor}
          showPlaceholderButton={showPlaceholderButton}
          availablePlaceholders={availablePlaceholders}
          onInsertPlaceholder={handleInsertPlaceholder}
          onInsertPageBreak={handleInsertPageBreak}
        />
        <EditorContent editor={editor} />
      </div>
    );
  }
);

// ============================================================================
// CSS Styles (add to global styles or include inline)
// ============================================================================

// Add these styles to your global CSS:
/*
.document-editor-content {
  line-height: 1.6;
}

.document-editor-content h1 {
  font-size: 1.75rem;
  font-weight: 700;
  margin: 1rem 0 0.5rem;
  color: var(--text-primary);
}

.document-editor-content h2 {
  font-size: 1.5rem;
  font-weight: 600;
  margin: 0.875rem 0 0.5rem;
  color: var(--text-primary);
}

.document-editor-content h3 {
  font-size: 1.25rem;
  font-weight: 600;
  margin: 0.75rem 0 0.375rem;
  color: var(--text-primary);
}

.document-editor-content p {
  margin: 0.5rem 0;
}

.document-editor-content .is-empty::before {
  content: attr(data-placeholder);
  color: var(--text-muted);
  pointer-events: none;
  position: absolute;
}

.document-editor-content .page-break {
  page-break-after: always;
  border-top: 2px dashed #ccc;
  margin: 20px 0;
  padding-top: 10px;
  text-align: center;
  color: #999;
  font-size: 12px;
}
*/

export default DocumentEditor;
